var cr = Object.defineProperty;
var dr = (e, t, n) => t in e ? cr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var $t = (e, t, n) => (dr(e, typeof t != "symbol" ? t + "" : t, n), n);
import { ref as ie, watch as le, customRef as fr, getCurrentScope as ei, onScopeDispose as Tt, unref as z, getCurrentInstance as tn, onMounted as be, nextTick as je, isRef as hr, computed as ne, onBeforeMount as gr, markRaw as Je, inject as Re, toRef as N, defineComponent as ce, createPropsRestProxy as ti, openBlock as te, createElementBlock as re, normalizeClass as Oe, renderSlot as ve, h as ae, effectScope as Vt, watchEffect as ni, provide as ot, onBeforeUnmount as Hn, normalizeStyle as ze, createBlock as Ne, resolveDynamicComponent as Ln, createCommentVNode as Ee, createElementVNode as it, mergeProps as oi, Fragment as Me, createTextVNode as vr, toDisplayString as Nn, Teleport as pr, normalizeProps as mr, reactive as yr, toRefs as xr, renderList as rt, resolveComponent as ii, createVNode as Ze, withCtx as He, onUnmounted as wr, useSlots as _r } from "vue";
var uo;
const ri = typeof window < "u", br = (e) => typeof e < "u", Nr = (e) => typeof e == "boolean", Pe = (e) => typeof e == "function", Le = (e) => typeof e == "number", Ie = (e) => typeof e == "string", Er = () => {
};
ri && ((uo = window == null ? void 0 : window.navigator) == null ? void 0 : uo.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function qe(e) {
  return typeof e == "function" ? e() : z(e);
}
function Sr(e, t) {
  function n(...o) {
    e(() => t.apply(this, o), { fn: t, thisArg: this, args: o });
  }
  return n;
}
const ai = (e) => e();
function Cr(e = ai) {
  const t = ie(!0);
  function n() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  return { isActive: t, pause: n, resume: o, eventFilter: (...r) => {
    t.value && e(...r);
  } };
}
function co(e, t = !1, n = "Timeout") {
  return new Promise((o, i) => {
    setTimeout(t ? () => i(n) : o, e);
  });
}
function $r(e) {
  return e;
}
function fo(e, t) {
  let n, o, i;
  const r = ie(!0), a = () => {
    r.value = !0, i();
  };
  le(e, a, { flush: "sync" });
  const s = Pe(t) ? t : t.get, l = Pe(t) ? void 0 : t.set, u = fr((c, f) => (o = c, i = f, {
    get() {
      return r.value && (n = s(), r.value = !1), o(), n;
    },
    set(d) {
      l == null || l(d);
    }
  }));
  return Object.isExtensible(u) && (u.trigger = a), u;
}
function X() {
  const e = [], t = (i) => {
    const r = e.indexOf(i);
    r !== -1 && e.splice(r, 1);
  };
  return {
    on: (i) => (e.push(i), {
      off: () => t(i)
    }),
    off: t,
    trigger: (i) => {
      e.forEach((r) => r(i));
    }
  };
}
function _t(e) {
  return ei() ? (Tt(e), !0) : !1;
}
function kr(e, t = !0) {
  tn() ? be(e) : t ? e() : je(e);
}
function En(e, t = !1) {
  function n(f, { flush: d = "sync", deep: w = !1, timeout: g, throwOnTimeout: h } = {}) {
    let _ = null;
    const b = [new Promise((S) => {
      _ = le(e, (y) => {
        f(y) !== t && (_ == null || _(), S(y));
      }, {
        flush: d,
        deep: w,
        immediate: !0
      });
    })];
    return g != null && b.push(co(g, h).then(() => qe(e)).finally(() => _ == null ? void 0 : _())), Promise.race(b);
  }
  function o(f, d) {
    if (!hr(f))
      return n((y) => y === f, d);
    const { flush: w = "sync", deep: g = !1, timeout: h, throwOnTimeout: _ } = d != null ? d : {};
    let v = null;
    const S = [new Promise((y) => {
      v = le([e, f], ([M, p]) => {
        t !== (M === p) && (v == null || v(), y(M));
      }, {
        flush: w,
        deep: g,
        immediate: !0
      });
    })];
    return h != null && S.push(co(h, _).then(() => qe(e)).finally(() => (v == null || v(), qe(e)))), Promise.race(S);
  }
  function i(f) {
    return n((d) => Boolean(d), f);
  }
  function r(f) {
    return o(null, f);
  }
  function a(f) {
    return o(void 0, f);
  }
  function s(f) {
    return n(Number.isNaN, f);
  }
  function l(f, d) {
    return n((w) => {
      const g = Array.from(w);
      return g.includes(f) || g.includes(qe(f));
    }, d);
  }
  function u(f) {
    return c(1, f);
  }
  function c(f = 1, d) {
    let w = -1;
    return n(() => (w += 1, w >= f), d);
  }
  return Array.isArray(qe(e)) ? {
    toMatch: n,
    toContains: l,
    changed: u,
    changedTimes: c,
    get not() {
      return En(e, !t);
    }
  } : {
    toMatch: n,
    toBe: o,
    toBeTruthy: i,
    toBeNull: r,
    toBeNaN: s,
    toBeUndefined: a,
    changed: u,
    changedTimes: c,
    get not() {
      return En(e, !t);
    }
  };
}
function Ke(e) {
  return En(e);
}
var ho = Object.getOwnPropertySymbols, Mr = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, zr = (e, t) => {
  var n = {};
  for (var o in e)
    Mr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && ho)
    for (var o of ho(e))
      t.indexOf(o) < 0 && Or.call(e, o) && (n[o] = e[o]);
  return n;
};
function Pr(e, t, n = {}) {
  const o = n, {
    eventFilter: i = ai
  } = o, r = zr(o, [
    "eventFilter"
  ]);
  return le(e, Sr(i, t), r);
}
var Ar = Object.defineProperty, Br = Object.defineProperties, Tr = Object.getOwnPropertyDescriptors, Ft = Object.getOwnPropertySymbols, si = Object.prototype.hasOwnProperty, li = Object.prototype.propertyIsEnumerable, go = (e, t, n) => t in e ? Ar(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ir = (e, t) => {
  for (var n in t || (t = {}))
    si.call(t, n) && go(e, n, t[n]);
  if (Ft)
    for (var n of Ft(t))
      li.call(t, n) && go(e, n, t[n]);
  return e;
}, Dr = (e, t) => Br(e, Tr(t)), Rr = (e, t) => {
  var n = {};
  for (var o in e)
    si.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Ft)
    for (var o of Ft(e))
      t.indexOf(o) < 0 && li.call(e, o) && (n[o] = e[o]);
  return n;
};
function Ge(e, t, n = {}) {
  const o = n, {
    eventFilter: i
  } = o, r = Rr(o, [
    "eventFilter"
  ]), { eventFilter: a, pause: s, resume: l, isActive: u } = Cr(i);
  return { stop: Pr(e, t, Dr(Ir({}, r), {
    eventFilter: a
  })), pause: s, resume: l, isActive: u };
}
function ui(e) {
  var t;
  const n = qe(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Vn = ri ? window : void 0;
function Fn(...e) {
  let t, n, o, i;
  if (Ie(e[0]) || Array.isArray(e[0]) ? ([n, o, i] = e, t = Vn) : [t, n, o, i] = e, !t)
    return Er;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const r = [], a = () => {
    r.forEach((c) => c()), r.length = 0;
  }, s = (c, f, d) => (c.addEventListener(f, d, i), () => c.removeEventListener(f, d, i)), l = le(() => ui(t), (c) => {
    a(), c && r.push(...n.flatMap((f) => o.map((d) => s(c, f, d))));
  }, { immediate: !0, flush: "post" }), u = () => {
    l(), a();
  };
  return _t(u), u;
}
const Hr = (e) => typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
function vo(...e) {
  let t, n, o = {};
  e.length === 3 ? (t = e[0], n = e[1], o = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], o = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const { target: i = Vn, eventName: r = "keydown", passive: a = !1 } = o, s = Hr(t);
  return Fn(i, r, (u) => {
    s(u) && n(u);
  }, a);
}
function Lr(e, t = !1) {
  const n = ie(), o = () => n.value = Boolean(e());
  return o(), kr(o, t), n;
}
function Vr(e) {
  return JSON.parse(JSON.stringify(e));
}
const Sn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Cn = "__vueuse_ssr_handlers__";
Sn[Cn] = Sn[Cn] || {};
Sn[Cn];
var po = Object.getOwnPropertySymbols, Fr = Object.prototype.hasOwnProperty, Yr = Object.prototype.propertyIsEnumerable, Xr = (e, t) => {
  var n = {};
  for (var o in e)
    Fr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && po)
    for (var o of po(e))
      t.indexOf(o) < 0 && Yr.call(e, o) && (n[o] = e[o]);
  return n;
};
function Zr(e, t, n = {}) {
  const o = n, { window: i = Vn } = o, r = Xr(o, ["window"]);
  let a;
  const s = Lr(() => i && "ResizeObserver" in i), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = le(() => ui(e), (f) => {
    l(), s.value && i && f && (a = new ResizeObserver(t), a.observe(f, r));
  }, { immediate: !0, flush: "post" }), c = () => {
    l(), u();
  };
  return _t(c), {
    isSupported: s,
    stop: c
  };
}
var mo;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(mo || (mo = {}));
var Kr = Object.defineProperty, yo = Object.getOwnPropertySymbols, Wr = Object.prototype.hasOwnProperty, Gr = Object.prototype.propertyIsEnumerable, xo = (e, t, n) => t in e ? Kr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ur = (e, t) => {
  for (var n in t || (t = {}))
    Wr.call(t, n) && xo(e, n, t[n]);
  if (yo)
    for (var n of yo(t))
      Gr.call(t, n) && xo(e, n, t[n]);
  return e;
};
const qr = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Ur({
  linear: $r
}, qr);
function gt(e, t, n, o = {}) {
  var i, r, a;
  const {
    clone: s = !1,
    passive: l = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: f
  } = o, d = tn(), w = n || (d == null ? void 0 : d.emit) || ((i = d == null ? void 0 : d.$emit) == null ? void 0 : i.bind(d)) || ((a = (r = d == null ? void 0 : d.proxy) == null ? void 0 : r.$emit) == null ? void 0 : a.bind(d == null ? void 0 : d.proxy));
  let g = u;
  t || (t = "modelValue"), g = u || g || `update:${t.toString()}`;
  const h = (v) => s ? Pe(s) ? s(v) : Vr(v) : v, _ = () => br(e[t]) ? h(e[t]) : f;
  if (l) {
    const v = _(), b = ie(v);
    return le(() => e[t], (S) => b.value = h(S)), le(b, (S) => {
      (S !== e[t] || c) && w(g, S);
    }, { deep: c }), b;
  } else
    return ne({
      get() {
        return _();
      },
      set(v) {
        w(g, v);
      }
    });
}
const Qr = () => ({
  edgesChange: X(),
  nodesChange: X(),
  nodeDoubleClick: X(),
  nodeClick: X(),
  nodeMouseEnter: X(),
  nodeMouseMove: X(),
  nodeMouseLeave: X(),
  nodeContextMenu: X(),
  nodeDragStart: X(),
  nodeDrag: X(),
  nodeDragStop: X(),
  nodesInitialized: X(),
  miniMapNodeClick: X(),
  miniMapNodeDoubleClick: X(),
  miniMapNodeMouseEnter: X(),
  miniMapNodeMouseMove: X(),
  miniMapNodeMouseLeave: X(),
  connect: X(),
  connectStart: X(),
  connectEnd: X(),
  paneReady: X(),
  move: X(),
  moveStart: X(),
  moveEnd: X(),
  selectionDragStart: X(),
  selectionDrag: X(),
  selectionDragStop: X(),
  selectionContextMenu: X(),
  selectionStart: X(),
  selectionEnd: X(),
  viewportChangeStart: X(),
  viewportChange: X(),
  viewportChangeEnd: X(),
  paneScroll: X(),
  paneClick: X(),
  paneContextMenu: X(),
  paneMouseEnter: X(),
  paneMouseMove: X(),
  paneMouseLeave: X(),
  edgeContextMenu: X(),
  edgeMouseEnter: X(),
  edgeMouseMove: X(),
  edgeMouseLeave: X(),
  edgeDoubleClick: X(),
  edgeClick: X(),
  edgeUpdateStart: X(),
  edgeUpdate: X(),
  edgeUpdateEnd: X(),
  updateNodeInternals: X()
});
function jr(e, t) {
  gr(() => {
    for (const [n, o] of Object.entries(t.value)) {
      const i = (r) => {
        e(n, r);
      };
      o.on(i), _t(() => {
        o.off(i);
      });
    }
  });
}
const Jr = ["production", "prod"], he = (e, ...t) => {
  Jr.includes(process.env.NODE_ENV || "") || console.warn(`[Vue Flow]: ${e}`, ...t);
}, bt = () => typeof window < "u" ? window : { chrome: !1 }, wo = (e) => ({
  ...e.computedPosition || { x: 0, y: 0 },
  width: e.dimensions.width || 0,
  height: e.dimensions.height || 0
}), $n = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * o);
}, nn = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), Yt = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), ci = (e, t) => ({
  x: Yt(e.x, t[0][0], t[1][0]),
  y: Yt(e.y, t[0][1], t[1][1])
}), hn = (e) => {
  const t = e.getRootNode(), n = bt();
  return "elementFromPoint" in t ? t : n.document;
}, Ae = (e) => e && "id" in e && "source" in e && "target" in e, Yn = (e) => Ae(e) && "sourceNode" in e && "targetNode" in e, Xn = (e) => e && "id" in e && !Ae(e), De = (e) => Xn(e) && "computedPosition" in e, ea = (e) => !!e.width && !!e.height && !!e.x && !!e.y, ta = (e, t, n) => {
  var i;
  let o = n;
  return De(e) || (o = {
    type: (i = e.type) != null ? i : "default",
    dimensions: Je({
      width: 0,
      height: 0
    }),
    handleBounds: {
      source: [],
      target: []
    },
    computedPosition: Je({
      z: 0,
      ...e.position
    }),
    draggable: void 0,
    selectable: void 0,
    connectable: void 0,
    focusable: void 0,
    selected: !1,
    dragging: !1,
    resizing: !1,
    initialized: !1,
    ...n,
    data: fe(e.data) ? e.data : {},
    events: Je(fe(e.events) ? e.events : {})
  }), {
    ...o,
    ...e,
    id: e.id.toString()
  };
}, Zn = (e, t) => {
  var i, r, a, s, l;
  const n = fe(e.events) ? e.events : (t == null ? void 0 : t.events) && fe(t == null ? void 0 : t.events) ? t == null ? void 0 : t.events : {}, o = fe(e.data) ? e.data : (t == null ? void 0 : t.data) && fe(t == null ? void 0 : t.data) ? t == null ? void 0 : t.data : {};
  return t = Yn(e) ? t : {
    ...t,
    sourceHandle: (e.sourceHandle ? e.sourceHandle.toString() : void 0) || (t == null ? void 0 : t.sourceHandle),
    targetHandle: (e.targetHandle ? e.targetHandle.toString() : void 0) || (t == null ? void 0 : t.targetHandle),
    type: (r = (i = e.type) != null ? i : t == null ? void 0 : t.type) != null ? r : "default",
    source: e.source.toString() || (t == null ? void 0 : t.source),
    target: e.target.toString() || (t == null ? void 0 : t.target),
    z: t == null ? void 0 : t.z,
    sourceX: t == null ? void 0 : t.sourceX,
    sourceY: t == null ? void 0 : t.sourceY,
    targetX: t == null ? void 0 : t.targetX,
    targetY: t == null ? void 0 : t.targetY,
    updatable: (a = e.updatable) != null ? a : t == null ? void 0 : t.updatable,
    selectable: (s = e.selectable) != null ? s : t == null ? void 0 : t.selectable,
    focusable: (l = e.focusable) != null ? l : t == null ? void 0 : t.focusable,
    data: o,
    events: Je(n),
    label: (e.label && !Ie(e.label) ? Je(e.label) : e.label) || (t == null ? void 0 : t.label),
    interactionWidth: e.interactionWidth || (t == null ? void 0 : t.interactionWidth)
  }, Object.assign({ id: e.id.toString() }, e, t);
}, di = (e, t, n) => {
  if (!Xn(e))
    return [];
  const o = n === "source" ? "target" : "source", i = t.filter((r) => Ae(r) && r[o] === e.id).map((r) => Ae(r) && r[n]);
  return t.filter((r) => i.includes(r.id));
}, fd = (e, t) => di(e, t, "target"), hd = (e, t) => di(e, t, "source"), on = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `vueflow__edge-${e}${t != null ? t : ""}-${n}${o != null ? o : ""}`, Kn = (e, t) => t.some(
  (n) => Ae(n) && n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)
), gd = (e, t, n) => {
  if (!e.source || !e.target)
    return he("Can't create edge. An edge needs a source and a target."), t;
  let o;
  return Ae(e) ? o = { ...e } : o = {
    ...e,
    id: on(e)
  }, o = Zn(o, n), Kn(o, t) || t.push(o), t;
}, vd = (e, t, n) => {
  if (!t.source || !t.target)
    return he("Can't create new edge. An edge needs a source and a target."), n;
  const o = n.find((r) => Ae(r) && r.id === e.id);
  if (!o)
    return he(`The old edge with id=${e.id} does not exist.`), n;
  const i = {
    ...e,
    id: on(t),
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(o), 1, i), n.filter((r) => r.id !== e.id);
}, fi = ({ x: e, y: t }, { x: n, y: o, zoom: i }, r, [a, s]) => {
  const l = {
    x: (e - n) / i,
    y: (t - o) / i
  };
  return r ? {
    x: a * Math.round(l.x / a),
    y: s * Math.round(l.y / s)
  } : l;
}, hi = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Xt = ({ x: e, y: t, width: n, height: o }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + o
}), gi = ({ x: e, y: t, x2: n, y2: o }) => ({
  x: e,
  y: t,
  width: n - e,
  height: o - t
}), pd = (e, t) => gi(hi(Xt(e), Xt(t))), vi = (e) => {
  const t = e.reduce(
    (n, { computedPosition: o = { x: 0, y: 0 }, dimensions: i = { width: 0, height: 0 } } = {}) => hi(
      n,
      Xt({
        ...o,
        ...i
      })
    ),
    { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
  );
  return gi(t);
}, md = ({ x: e, y: t }, { x: n, y: o, zoom: i }) => ({
  x: e * i + n,
  y: t * i + o
}), pi = (e, t, { x: n, y: o, zoom: i } = { x: 0, y: 0, zoom: 1 }, r = !1, a = !1) => {
  const s = {
    x: (t.x - n) / i,
    y: (t.y - o) / i,
    width: t.width / i,
    height: t.height / i
  };
  return e.filter((l) => {
    const { computedPosition: u = { x: 0, y: 0 }, dimensions: c = { width: 0, height: 0 }, selectable: f } = l;
    if (a && !f)
      return !1;
    const d = { ...u, width: c.width || 0, height: c.height || 0 }, w = $n(s, d), g = typeof c.width > "u" || typeof c.height > "u" || c.width === 0 || c.height === 0, h = r && w > 0, _ = c.width * c.height;
    return g || h || w >= _;
  });
}, rn = (e, t) => {
  const n = e.map((o) => o.id);
  return t.filter((o) => n.includes(o.source) || n.includes(o.target));
}, _o = (e, t, n, o, i, r = 0.1, a = { x: 0, y: 0 }) => {
  var h, _;
  const s = t / (e.width * (1 + r)), l = n / (e.height * (1 + r)), u = Math.min(s, l), c = Yt(u, o, i), f = e.x + e.width / 2, d = e.y + e.height / 2, w = t / 2 - f * c + ((h = a.x) != null ? h : 0), g = n / 2 - d * c + ((_ = a.y) != null ? _ : 0);
  return { x: w, y: g, zoom: c };
}, na = (e, t) => ({
  x: t.x + e.x,
  y: t.y + e.y,
  z: (e.z > t.z ? e.z : t.z) + 1
}), mi = (e, t) => {
  if (!e.parentNode)
    return !1;
  const n = t(e.parentNode);
  return n ? n.selected ? !0 : mi(n, t) : !1;
}, Ve = (e, t) => typeof e > "u" ? "" : typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((o) => `${o}=${e[o]}`).join("&")}`, fe = (e) => typeof z(e) < "u", oa = (e, t) => {
  if (!e.source || !e.target)
    return he("Can't create edge. An edge needs a source and a target."), !1;
  let n;
  return Ae(e) ? n = { ...e } : n = {
    ...e,
    id: on(e)
  }, n = Zn(n), Kn(n, t) ? !1 : n;
}, ia = (e, t, n) => {
  if (!t.source || !t.target)
    return he("Can't create new edge. An edge needs a source and a target."), !1;
  const o = n.find((r) => Yn(r) && r.id === e.id);
  if (!o)
    return he(`The old edge with id=${e.id} does not exist.`), !1;
  const i = {
    ...e,
    id: on(t),
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(o), 1, i), i;
}, bo = (e, t, n, o) => {
  const i = {}, r = e.map((a) => {
    const s = ta(a, o, {
      ...t(a.id),
      parentNode: a.parentNode
    });
    return a.parentNode && (i[a.parentNode] = !0), s;
  });
  return r.forEach((a) => {
    const s = [...r, ...n];
    if (a.parentNode && !s.find((l) => l.id === a.parentNode) && he(`Parent node ${a.parentNode} not found`), a.parentNode || i[a.id]) {
      i[a.id] && (a.isParent = !0);
      const l = a.parentNode ? t(a.parentNode) : void 0;
      l && (l.isParent = !0);
    }
  }), r;
};
var q = /* @__PURE__ */ ((e) => (e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom", e))(q || {}), Wn = /* @__PURE__ */ ((e) => (e.Partial = "partial", e.Full = "full", e))(Wn || {}), Fe = /* @__PURE__ */ ((e) => (e.Bezier = "default", e.SimpleBezier = "simple-bezier", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e))(Fe || {}), at = /* @__PURE__ */ ((e) => (e.Strict = "strict", e.Loose = "loose", e))(at || {}), ra = /* @__PURE__ */ ((e) => (e.Arrow = "arrow", e.ArrowClosed = "arrowclosed", e))(ra || {}), Zt = /* @__PURE__ */ ((e) => (e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal", e))(Zt || {}), aa = /* @__PURE__ */ ((e) => (e.TopLeft = "top-left", e.TopCenter = "top-center", e.TopRight = "top-right", e.BottomLeft = "bottom-left", e.BottomCenter = "bottom-center", e.BottomRight = "bottom-right", e))(aa || {});
const No = Symbol("vueFlow"), yi = Symbol("nodeId"), xi = Symbol("nodeRef"), wi = Symbol("edgeId"), _i = Symbol("edgeRef"), an = Symbol("slots");
function sa(e) {
  const t = e != null ? e : Re(yi, ""), n = Re(xi, null), { findNode: o, getEdges: i } = ue(), r = o(t);
  if (!r)
    throw new Error(`[vue-flow]: useNode - Node with id ${t} not found!`);
  return {
    id: t,
    nodeEl: n,
    node: r,
    parentNode: ne(() => r.parentNode ? o(r.parentNode) : void 0),
    connectedEdges: ne(() => rn([r], i.value))
  };
}
const ut = (e, t, n, o, i, r, a, s, l) => {
  var h, _;
  const u = e.touches ? e.touches[0].clientX : e.clientX, c = e.touches ? e.touches[0].clientY : e.clientY, f = a.elementFromPoint(u, c), d = (f == null ? void 0 : f.classList.contains("target")) || !1, w = (f == null ? void 0 : f.classList.contains("source")) || !1, g = {
    elementBelow: f,
    isValid: !1,
    connection: { source: "", target: "", sourceHandle: null, targetHandle: null },
    isHoveringHandle: !1
  };
  if (f && (d || w) && (g.isHoveringHandle = !0, t === at.Strict ? n && w || !n && d : !0)) {
    const b = (h = f.getAttribute("data-nodeid")) != null ? h : "", S = (_ = f.getAttribute("data-handleid")) != null ? _ : "", y = n ? b : o, M = n ? S : i, p = n ? o : b, R = {
      source: y,
      sourceHandle: M,
      target: p,
      targetHandle: n ? i : S
    };
    g.connection = R, g.isValid = (Pe(r) ? r(R, { edges: s, sourceNode: l(y), targetNode: l(p) }) : b !== o || S !== i) || !g.connection.target || !g.connection.source;
  }
  return g;
}, kt = (e) => {
  e == null || e.classList.remove("vue-flow__handle-valid"), e == null || e.classList.remove("vue-flow__handle-connecting");
};
function bi({
  handleId: e,
  nodeId: t,
  isValidConnection: n,
  type: o,
  elementEdgeUpdaterType: i,
  onEdgeUpdateEnd: r,
  onEdgeUpdate: a
}) {
  const s = ue(), l = N(s, "edges"), u = N(s, "connectOnClick"), c = N(s, "nodesConnectable"), f = N(s, "connectionClickStartHandle"), d = N(s, "connectionMode"), w = N(s, "emits"), g = N(s, "startConnection"), h = N(s, "updateConnection"), _ = N(s, "endConnection"), v = N(s, "getNode"), b = N(s, "vueFlowRef"), S = ne(() => z(o) === "target");
  let y;
  const M = (D) => {
    if (D.button !== 0)
      return;
    const I = hn(D.target);
    if (!I)
      return;
    let G = n;
    const Z = v.value(z(t));
    if (Z && (typeof Z.connectable > "u" ? c.value : Z.connectable) === !1)
      return;
    n || Z && (G = S.value ? Z.isValidSourcePos : Z.isValidTargetPos);
    const j = I.elementFromPoint(D.clientX, D.clientY), m = j == null ? void 0 : j.classList.contains("target"), A = j == null ? void 0 : j.classList.contains("source");
    if (!b.value || !m && !A && !i)
      return;
    const C = i != null ? i : m ? "target" : "source", B = b.value.getBoundingClientRect();
    g.value(
      {
        nodeId: z(t),
        handleId: z(e),
        type: z(C)
      },
      {
        x: D.clientX - B.left,
        y: D.clientY - B.top
      },
      D
    );
    function F(k) {
      h.value({
        x: k.clientX - B.left,
        y: k.clientY - B.top
      });
      const { connection: L, elementBelow: K, isValid: oe, isHoveringHandle: $ } = ut(
        k,
        d.value,
        z(S.value),
        z(t),
        z(e),
        G,
        I,
        l.value,
        v.value
      );
      if (!$)
        return kt(y);
      !(L.source === L.target) && K && (y = K, K.classList.add("vue-flow__handle-connecting"), K.classList.toggle("vue-flow__handle-valid", oe));
    }
    function P(k) {
      const { connection: L, isValid: K } = ut(
        k,
        d.value,
        z(S.value),
        z(t),
        z(e),
        G,
        I,
        l.value,
        v.value
      ), oe = L.source === L.target;
      K && !oe && (a ? a(L) : w.value.connect(L)), i && (r == null || r()), kt(y), _.value(k), I.removeEventListener("mousemove", F), I.removeEventListener("mouseup", P);
    }
    I.addEventListener("mousemove", F), I.addEventListener("mouseup", P);
  }, p = ie({ x: 0, y: 0 });
  return {
    onMouseDown: M,
    onTouchStart: (D) => {
      const I = D.touches[0].clientX, G = D.touches[0].clientY, Z = hn(D.target);
      if (!Z)
        return;
      let j = n;
      const m = v.value(z(t));
      if (m && (typeof m.connectable > "u" ? c.value : m.connectable) === !1)
        return;
      n || m && (j = S.value ? m.isValidSourcePos : m.isValidTargetPos);
      const A = Z.elementFromPoint(I, G), C = A == null ? void 0 : A.classList.contains("target"), B = A == null ? void 0 : A.classList.contains("source");
      if (!b.value || !C && !B && !i)
        return;
      const F = i != null ? i : C ? "target" : "source", P = b.value.getBoundingClientRect();
      g.value(
        {
          nodeId: z(t),
          handleId: z(e),
          type: z(F)
        },
        {
          x: I - P.left,
          y: G - P.top
        },
        D
      );
      function k(K) {
        h.value({
          x: K.touches[0].clientX - P.left,
          y: K.touches[0].clientY - P.top
        }), p.value = {
          x: K.touches[0].clientX,
          y: K.touches[0].clientY
        };
        const { connection: oe, elementBelow: $, isValid: Y, isHoveringHandle: U } = ut(
          K,
          d.value,
          z(S.value),
          z(t),
          z(e),
          j,
          Z,
          l.value,
          v.value
        );
        if (!U)
          return kt(y);
        !(oe.source === oe.target) && $ && (y = $, $.classList.add("vue-flow__handle-connecting"), $.classList.toggle("vue-flow__handle-valid", Y));
      }
      function L(K) {
        const { connection: oe, isValid: $ } = ut(
          { clientX: p.value.x, clientY: p.value.y },
          d.value,
          z(S.value),
          z(t),
          z(e),
          j,
          Z,
          l.value,
          v.value
        ), Y = oe.source === oe.target;
        $ && !Y && (a ? a(oe) : w.value.connect(oe)), i && (r == null || r()), kt(y), _.value(K), p.value = { x: 0, y: 0 }, Z.removeEventListener("touchmove", k), Z.removeEventListener("touchend", L);
      }
      Z.addEventListener("touchmove", k), Z.addEventListener("touchend", L);
    },
    onClick: (D) => {
      var I;
      if (!!u.value)
        if (!f.value)
          g.value({ nodeId: z(t), type: z(o), handleId: z(e) }, void 0, D, !0);
        else {
          let G = n != null ? n : () => !0;
          const Z = v.value(z(t));
          if (Z && (typeof Z.connectable > "u" ? c.value : Z.connectable) === !1)
            return;
          n || Z && (G = (I = S.value ? Z.isValidSourcePos : Z.isValidTargetPos) != null ? I : () => !0);
          const j = hn(D.target), { connection: m, isValid: A } = ut(
            D,
            d.value,
            f.value.type === "target",
            f.value.nodeId,
            f.value.handleId || null,
            G,
            j,
            l.value,
            v.value
          ), C = m.source === m.target;
          A && !C && w.value.connect(m), _.value(D, !0);
        }
    }
  };
}
const la = ["data-handleid", "data-nodeid", "data-handlepos"], ua = {
  name: "Handle"
}, Kt = /* @__PURE__ */ ce({
  ...ua,
  props: {
    id: null,
    type: null,
    position: { default: () => "top" },
    isValidConnection: null,
    connectable: { type: [Boolean, String, Function], default: !0 }
  },
  setup(e) {
    const t = ti(e, ["position", "connectable", "id", "isValidConnection"]), n = N(t, "type", "source"), o = ue(), i = N(o, "connectionStartHandle"), r = N(o, "vueFlowRef"), a = N(o, "nodesConnectable"), { id: s, node: l, nodeEl: u, connectedEdges: c } = sa(), f = ie(), d = ne(() => {
      var v;
      return (v = e.id) != null ? v : `${s}__handle-${e.position}`;
    }), { onMouseDown: w, onTouchStart: g, onClick: h } = bi({
      nodeId: s,
      handleId: d.value,
      isValidConnection: e.isValidConnection,
      type: n
    }), _ = ne(() => Ie(e.connectable) && e.connectable === "single" ? !c.value.some((v) => {
      const b = v[`${n.value}Handle`];
      return v[n.value] !== s ? !1 : b ? b === d.value : !0;
    }) : Pe(e.connectable) ? e.connectable(l, c.value) : fe(e.connectable) ? e.connectable : a.value);
    return be(() => {
      Ke(() => l.initialized).toBe(!0).then(() => {
        var R, D;
        const v = (R = l.handleBounds[n.value]) == null ? void 0 : R.find((I) => I.id === d.value);
        if (!r.value || v)
          return;
        const b = r.value.querySelector(".vue-flow__transformationpane");
        if (!u || !f.value || !b || !d.value)
          return;
        const S = u.value.getBoundingClientRect(), y = f.value.getBoundingClientRect(), M = window.getComputedStyle(b), { m22: p } = new window.DOMMatrixReadOnly(M.transform), O = {
          id: d.value,
          position: e.position,
          x: (y.left - S.left) / p,
          y: (y.top - S.top) / p,
          ...nn(f.value)
        };
        l.handleBounds[n.value] = [...(D = l.handleBounds[n.value]) != null ? D : [], O];
      });
    }), (v, b) => (te(), re("div", {
      ref_key: "handle",
      ref: f,
      "data-handleid": d.value,
      "data-nodeid": z(s),
      "data-handlepos": e.position,
      class: Oe(["vue-flow__handle nodrag", [
        `vue-flow__handle-${e.position}`,
        `vue-flow__handle-${d.value}`,
        {
          source: z(n) !== "target",
          target: z(n) === "target",
          connectable: z(_),
          connecting: i.value && i.value.nodeId === z(s) && i.value.handleId === d.value && i.value.type === z(n)
        }
      ]]),
      onMousedown: b[0] || (b[0] = (...S) => z(w) && z(w)(...S)),
      onTouchstart: b[1] || (b[1] = (...S) => z(g) && z(g)(...S)),
      onClick: b[2] || (b[2] = (...S) => z(h) && z(h)(...S))
    }, [
      ve(v.$slots, "default", { id: e.id })
    ], 42, la));
  }
}), Gn = function({
  sourcePosition: e = q.Bottom,
  targetPosition: t = q.Top,
  label: n,
  connectable: o = !0,
  isValidTargetPos: i,
  isValidSourcePos: r
}) {
  return [
    ae(Kt, { type: "target", position: t, connectable: o, isValidConnection: i }),
    typeof n != "string" && n ? ae(n) : ae("div", { innerHTML: n }),
    ae(Kt, { type: "source", position: e, connectable: o, isValidConnection: r })
  ];
};
Gn.props = ["sourcePosition", "targetPosition", "label", "isValidTargetPos", "isValidSourcePos", "connectable"];
Gn.inheritAttrs = !1;
const ca = Gn, Un = function({
  sourcePosition: e = q.Bottom,
  label: t,
  connectable: n = !0,
  isValidSourcePos: o
}) {
  return [
    typeof t != "string" && t ? ae(t) : ae("div", { innerHTML: t }),
    ae(Kt, { type: "source", position: e, connectable: n, isValidConnection: o })
  ];
};
Un.props = ["sourcePosition", "label", "isValidSourcePos", "connectable"];
Un.inheritAttrs = !1;
const da = Un, qn = function({
  targetPosition: e = q.Top,
  label: t,
  connectable: n = !0,
  isValidTargetPos: o
}) {
  return [
    ae(Kt, { type: "target", position: e, connectable: n, isValidConnection: o }),
    typeof t != "string" && t ? ae(t) : ae("div", { innerHTML: t })
  ];
};
qn.props = ["targetPosition", "label", "isValidTargetPos", "connectable"];
qn.inheritAttrs = !1;
const fa = qn;
function Eo(e, t, n) {
  let o = e;
  do {
    if (o && o.matches(t))
      return !0;
    if (o === n.value)
      return !1;
    o = o.parentElement;
  } while (o);
  return !1;
}
function ha(e, t, n, o) {
  return e.filter((i) => (i.selected || i.id === o) && (!i.parentNode || !mi(i, n))).map(
    (i) => {
      var r, a;
      return Je({
        id: i.id,
        position: i.position || { x: 0, y: 0 },
        distance: {
          x: t.x - ((r = i.computedPosition) == null ? void 0 : r.x) || 0,
          y: t.y - ((a = i.computedPosition) == null ? void 0 : a.y) || 0
        },
        from: i.computedPosition,
        extent: i.extent,
        parentNode: i.parentNode,
        dimensions: i.dimensions
      });
    }
  );
}
function gn({
  id: e,
  dragItems: t,
  getNode: n
}) {
  const o = t.map((i) => ({
    ...n.value(i.id)
  }));
  return [e ? o.find((i) => i.id === e) : o[0], o];
}
function ga(e, t, n) {
  let o = e.extent || t;
  if (e.extent === "parent")
    e.parentNode && n && e.dimensions.width && e.dimensions.height ? o = n && Le(n.computedPosition.x) && Le(n.computedPosition.y) && Le(n.dimensions.width) && Le(n.dimensions.height) ? [
      [n.computedPosition.x, n.computedPosition.y],
      [
        n.computedPosition.x + n.dimensions.width - e.dimensions.width,
        n.computedPosition.y + n.dimensions.height - e.dimensions.height
      ]
    ] : o : (he("Only child nodes can use a parent extent."), o = t);
  else if (e.extent && n) {
    const i = n.computedPosition.x, r = n.computedPosition.y;
    o = [
      [e.extent[0][0] + i, e.extent[0][1] + r],
      [e.extent[1][0] + i, e.extent[1][1] + r]
    ];
  }
  return o;
}
const Wt = (e, t, n, o) => {
  const i = ga(e, n, o);
  return {
    position: ci(t, i)
  };
};
function Ni() {
  const { getSelectedNodes: e, nodeExtent: t, updateNodePositions: n, findNode: o, snapGrid: i, snapToGrid: r } = ue();
  return (a, s = !1) => {
    const l = r.value ? i.value[0] : 5, u = r.value ? i.value[1] : 5, c = s ? 4 : 1, f = a.x * l * c, d = a.y * u * c, w = e.value.map((g) => {
      const h = { x: g.computedPosition.x + f, y: g.computedPosition.y + d }, _ = Wt(g, h, t.value, g.parentNode ? o(g.parentNode) : void 0);
      return {
        id: g.id,
        position: _.position,
        from: g.position,
        distance: { x: a.x, y: a.y },
        dimensions: g.dimensions
      };
    });
    n(w, !0, !1);
  };
}
const va = () => ({
  doubleClick: X(),
  click: X(),
  mouseEnter: X(),
  mouseMove: X(),
  mouseLeave: X(),
  contextMenu: X(),
  dragStart: X(),
  drag: X(),
  dragStop: X()
});
function pa(e, t) {
  const n = va();
  return n.doubleClick.on((o) => {
    var i, r;
    t.nodeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.nodeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.nodeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.nodeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.nodeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.nodeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.dragStart.on((o) => {
    var i, r;
    t.nodeDragStart(o), (r = (i = e.events) == null ? void 0 : i.dragStart) == null || r.call(i, o);
  }), n.drag.on((o) => {
    var i, r;
    t.nodeDrag(o), (r = (i = e.events) == null ? void 0 : i.drag) == null || r.call(i, o);
  }), n.dragStop.on((o) => {
    var i, r;
    t.nodeDragStop(o), (r = (i = e.events) == null ? void 0 : i.dragStop) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
function ma() {
  const { viewport: e, snapGrid: t, snapToGrid: n } = ue(), o = (i) => (i != null ? i : n.value) ? t.value : void 0;
  return ({ sourceEvent: i }, r) => {
    const a = z(o(r)), s = i.touches ? i.touches[0].clientX : i.clientX, l = i.touches ? i.touches[0].clientY : i.clientY, u = {
      x: (s - e.value.x) / e.value.zoom,
      y: (l - e.value.y) / e.value.zoom
    };
    return {
      xSnapped: a ? a[0] * Math.round(u.x / a[0]) : u.x,
      ySnapped: a ? a[1] * Math.round(u.y / a[1]) : u.y,
      ...u
    };
  };
}
const So = (e, t, n) => {
  const o = t.querySelectorAll(`.vue-flow__handle${e}`);
  if (!o || !o.length)
    return;
  const i = Array.from(o), r = t.getBoundingClientRect();
  return i.map((a) => {
    const s = a.getBoundingClientRect();
    return {
      id: a.getAttribute("data-handleid"),
      position: a.getAttribute("data-handlepos"),
      x: (s.left - r.left) / n,
      y: (s.top - r.top) / n,
      ...nn(a)
    };
  });
}, kn = (e, t, n, o, i, r = !1) => {
  i.value = !1, e.selected ? (r || e.selected && t) && o([e]) : n([e]);
};
var ya = { value: () => {
} };
function sn() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + "") || o in n || /[\s.]/.test(o))
      throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new It(n);
}
function It(e) {
  this._ = e;
}
function xa(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var o = "", i = n.indexOf(".");
    if (i >= 0 && (o = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
It.prototype = sn.prototype = {
  constructor: It,
  on: function(e, t) {
    var n = this._, o = xa(e + "", n), i, r = -1, a = o.length;
    if (arguments.length < 2) {
      for (; ++r < a; )
        if ((i = (e = o[r]).type) && (i = wa(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++r < a; )
      if (i = (e = o[r]).type)
        n[i] = Co(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Co(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new It(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), o = 0, i, r; o < i; ++o)
        n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (r = this._[e], o = 0, i = r.length; o < i; ++o)
      r[o].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var o = this._[e], i = 0, r = o.length; i < r; ++i)
      o[i].value.apply(t, n);
  }
};
function wa(e, t) {
  for (var n = 0, o = e.length, i; n < o; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Co(e, t, n) {
  for (var o = 0, i = e.length; o < i; ++o)
    if (e[o].name === t) {
      e[o] = ya, e = e.slice(0, o).concat(e.slice(o + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Mn = "http://www.w3.org/1999/xhtml";
const $o = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Mn,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function ln(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), $o.hasOwnProperty(t) ? { space: $o[t], local: e } : e;
}
function _a(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Mn && t.documentElement.namespaceURI === Mn ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function ba(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Ei(e) {
  var t = ln(e);
  return (t.local ? ba : _a)(t);
}
function Na() {
}
function Qn(e) {
  return e == null ? Na : function() {
    return this.querySelector(e);
  };
}
function Ea(e) {
  typeof e != "function" && (e = Qn(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = new Array(a), l, u, c = 0; c < a; ++c)
      (l = r[c]) && (u = e.call(l, l.__data__, c, r)) && ("__data__" in l && (u.__data__ = l.__data__), s[c] = u);
  return new pe(o, this._parents);
}
function Sa(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Ca() {
  return [];
}
function Si(e) {
  return e == null ? Ca : function() {
    return this.querySelectorAll(e);
  };
}
function $a(e) {
  return function() {
    return Sa(e.apply(this, arguments));
  };
}
function ka(e) {
  typeof e == "function" ? e = $a(e) : e = Si(e);
  for (var t = this._groups, n = t.length, o = [], i = [], r = 0; r < n; ++r)
    for (var a = t[r], s = a.length, l, u = 0; u < s; ++u)
      (l = a[u]) && (o.push(e.call(l, l.__data__, u, a)), i.push(l));
  return new pe(o, i);
}
function Ci(e) {
  return function() {
    return this.matches(e);
  };
}
function $i(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Ma = Array.prototype.find;
function Oa(e) {
  return function() {
    return Ma.call(this.children, e);
  };
}
function za() {
  return this.firstElementChild;
}
function Pa(e) {
  return this.select(e == null ? za : Oa(typeof e == "function" ? e : $i(e)));
}
var Aa = Array.prototype.filter;
function Ba() {
  return Array.from(this.children);
}
function Ta(e) {
  return function() {
    return Aa.call(this.children, e);
  };
}
function Ia(e) {
  return this.selectAll(e == null ? Ba : Ta(typeof e == "function" ? e : $i(e)));
}
function Da(e) {
  typeof e != "function" && (e = Ci(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = [], l, u = 0; u < a; ++u)
      (l = r[u]) && e.call(l, l.__data__, u, r) && s.push(l);
  return new pe(o, this._parents);
}
function ki(e) {
  return new Array(e.length);
}
function Ra() {
  return new pe(this._enter || this._groups.map(ki), this._parents);
}
function Gt(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Gt.prototype = {
  constructor: Gt,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Ha(e) {
  return function() {
    return e;
  };
}
function La(e, t, n, o, i, r) {
  for (var a = 0, s, l = t.length, u = r.length; a < u; ++a)
    (s = t[a]) ? (s.__data__ = r[a], o[a] = s) : n[a] = new Gt(e, r[a]);
  for (; a < l; ++a)
    (s = t[a]) && (i[a] = s);
}
function Va(e, t, n, o, i, r, a) {
  var s, l, u = /* @__PURE__ */ new Map(), c = t.length, f = r.length, d = new Array(c), w;
  for (s = 0; s < c; ++s)
    (l = t[s]) && (d[s] = w = a.call(l, l.__data__, s, t) + "", u.has(w) ? i[s] = l : u.set(w, l));
  for (s = 0; s < f; ++s)
    w = a.call(e, r[s], s, r) + "", (l = u.get(w)) ? (o[s] = l, l.__data__ = r[s], u.delete(w)) : n[s] = new Gt(e, r[s]);
  for (s = 0; s < c; ++s)
    (l = t[s]) && u.get(d[s]) === l && (i[s] = l);
}
function Fa(e) {
  return e.__data__;
}
function Ya(e, t) {
  if (!arguments.length)
    return Array.from(this, Fa);
  var n = t ? Va : La, o = this._parents, i = this._groups;
  typeof e != "function" && (e = Ha(e));
  for (var r = i.length, a = new Array(r), s = new Array(r), l = new Array(r), u = 0; u < r; ++u) {
    var c = o[u], f = i[u], d = f.length, w = Xa(e.call(c, c && c.__data__, u, o)), g = w.length, h = s[u] = new Array(g), _ = a[u] = new Array(g), v = l[u] = new Array(d);
    n(c, f, h, _, v, w, t);
    for (var b = 0, S = 0, y, M; b < g; ++b)
      if (y = h[b]) {
        for (b >= S && (S = b + 1); !(M = _[S]) && ++S < g; )
          ;
        y._next = M || null;
      }
  }
  return a = new pe(a, o), a._enter = s, a._exit = l, a;
}
function Xa(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Za() {
  return new pe(this._exit || this._groups.map(ki), this._parents);
}
function Ka(e, t, n) {
  var o = this.enter(), i = this, r = this.exit();
  return typeof e == "function" ? (o = e(o), o && (o = o.selection())) : o = o.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? r.remove() : n(r), o && i ? o.merge(i).order() : i;
}
function Wa(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, i = n.length, r = o.length, a = Math.min(i, r), s = new Array(i), l = 0; l < a; ++l)
    for (var u = n[l], c = o[l], f = u.length, d = s[l] = new Array(f), w, g = 0; g < f; ++g)
      (w = u[g] || c[g]) && (d[g] = w);
  for (; l < i; ++l)
    s[l] = n[l];
  return new pe(s, this._parents);
}
function Ga() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var o = e[t], i = o.length - 1, r = o[i], a; --i >= 0; )
      (a = o[i]) && (r && a.compareDocumentPosition(r) ^ 4 && r.parentNode.insertBefore(a, r), r = a);
  return this;
}
function Ua(e) {
  e || (e = qa);
  function t(f, d) {
    return f && d ? e(f.__data__, d.__data__) : !f - !d;
  }
  for (var n = this._groups, o = n.length, i = new Array(o), r = 0; r < o; ++r) {
    for (var a = n[r], s = a.length, l = i[r] = new Array(s), u, c = 0; c < s; ++c)
      (u = a[c]) && (l[c] = u);
    l.sort(t);
  }
  return new pe(i, this._parents).order();
}
function qa(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Qa() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function ja() {
  return Array.from(this);
}
function Ja() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length; i < r; ++i) {
      var a = o[i];
      if (a)
        return a;
    }
  return null;
}
function es() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function ts() {
  return !this.node();
}
function ns(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n)
    for (var i = t[n], r = 0, a = i.length, s; r < a; ++r)
      (s = i[r]) && e.call(s, s.__data__, r, i);
  return this;
}
function os(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function is(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function rs(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function as(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function ss(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function ls(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function us(e, t) {
  var n = ln(e);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((t == null ? n.local ? is : os : typeof t == "function" ? n.local ? ls : ss : n.local ? as : rs)(n, t));
}
function Mi(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function cs(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function ds(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function fs(e, t, n) {
  return function() {
    var o = t.apply(this, arguments);
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
  };
}
function hs(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? cs : typeof t == "function" ? fs : ds)(e, t, n == null ? "" : n)) : st(this.node(), e);
}
function st(e, t) {
  return e.style.getPropertyValue(t) || Mi(e).getComputedStyle(e, null).getPropertyValue(t);
}
function gs(e) {
  return function() {
    delete this[e];
  };
}
function vs(e, t) {
  return function() {
    this[e] = t;
  };
}
function ps(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function ms(e, t) {
  return arguments.length > 1 ? this.each((t == null ? gs : typeof t == "function" ? ps : vs)(e, t)) : this.node()[e];
}
function Oi(e) {
  return e.trim().split(/^|\s+/);
}
function jn(e) {
  return e.classList || new zi(e);
}
function zi(e) {
  this._node = e, this._names = Oi(e.getAttribute("class") || "");
}
zi.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Pi(e, t) {
  for (var n = jn(e), o = -1, i = t.length; ++o < i; )
    n.add(t[o]);
}
function Ai(e, t) {
  for (var n = jn(e), o = -1, i = t.length; ++o < i; )
    n.remove(t[o]);
}
function ys(e) {
  return function() {
    Pi(this, e);
  };
}
function xs(e) {
  return function() {
    Ai(this, e);
  };
}
function ws(e, t) {
  return function() {
    (t.apply(this, arguments) ? Pi : Ai)(this, e);
  };
}
function _s(e, t) {
  var n = Oi(e + "");
  if (arguments.length < 2) {
    for (var o = jn(this.node()), i = -1, r = n.length; ++i < r; )
      if (!o.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? ws : t ? ys : xs)(n, t));
}
function bs() {
  this.textContent = "";
}
function Ns(e) {
  return function() {
    this.textContent = e;
  };
}
function Es(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t == null ? "" : t;
  };
}
function Ss(e) {
  return arguments.length ? this.each(e == null ? bs : (typeof e == "function" ? Es : Ns)(e)) : this.node().textContent;
}
function Cs() {
  this.innerHTML = "";
}
function $s(e) {
  return function() {
    this.innerHTML = e;
  };
}
function ks(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t == null ? "" : t;
  };
}
function Ms(e) {
  return arguments.length ? this.each(e == null ? Cs : (typeof e == "function" ? ks : $s)(e)) : this.node().innerHTML;
}
function Os() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function zs() {
  return this.each(Os);
}
function Ps() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function As() {
  return this.each(Ps);
}
function Bs(e) {
  var t = typeof e == "function" ? e : Ei(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Ts() {
  return null;
}
function Is(e, t) {
  var n = typeof e == "function" ? e : Ei(e), o = t == null ? Ts : typeof t == "function" ? t : Qn(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function Ds() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Rs() {
  return this.each(Ds);
}
function Hs() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Ls() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Vs(e) {
  return this.select(e ? Ls : Hs);
}
function Fs(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function Ys(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Xs(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", o = t.indexOf(".");
    return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: n };
  });
}
function Zs(e) {
  return function() {
    var t = this.__on;
    if (!!t) {
      for (var n = 0, o = -1, i = t.length, r; n < i; ++n)
        r = t[n], (!e.type || r.type === e.type) && r.name === e.name ? this.removeEventListener(r.type, r.listener, r.options) : t[++o] = r;
      ++o ? t.length = o : delete this.__on;
    }
  };
}
function Ks(e, t, n) {
  return function() {
    var o = this.__on, i, r = Ys(t);
    if (o) {
      for (var a = 0, s = o.length; a < s; ++a)
        if ((i = o[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = r, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, r, n), i = { type: e.type, name: e.name, value: t, listener: r, options: n }, o ? o.push(i) : this.__on = [i];
  };
}
function Ws(e, t, n) {
  var o = Xs(e + ""), i, r = o.length, a;
  if (arguments.length < 2) {
    var s = this.node().__on;
    if (s) {
      for (var l = 0, u = s.length, c; l < u; ++l)
        for (i = 0, c = s[l]; i < r; ++i)
          if ((a = o[i]).type === c.type && a.name === c.name)
            return c.value;
    }
    return;
  }
  for (s = t ? Ks : Zs, i = 0; i < r; ++i)
    this.each(s(o[i], t, n));
  return this;
}
function Bi(e, t, n) {
  var o = Mi(e), i = o.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = o.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function Gs(e, t) {
  return function() {
    return Bi(this, e, t);
  };
}
function Us(e, t) {
  return function() {
    return Bi(this, e, t.apply(this, arguments));
  };
}
function qs(e, t) {
  return this.each((typeof t == "function" ? Us : Gs)(e, t));
}
function* Qs() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length, a; i < r; ++i)
      (a = o[i]) && (yield a);
}
var Ti = [null];
function pe(e, t) {
  this._groups = e, this._parents = t;
}
function Nt() {
  return new pe([[document.documentElement]], Ti);
}
function js() {
  return this;
}
pe.prototype = Nt.prototype = {
  constructor: pe,
  select: Ea,
  selectAll: ka,
  selectChild: Pa,
  selectChildren: Ia,
  filter: Da,
  data: Ya,
  enter: Ra,
  exit: Za,
  join: Ka,
  merge: Wa,
  selection: js,
  order: Ga,
  sort: Ua,
  call: Qa,
  nodes: ja,
  node: Ja,
  size: es,
  empty: ts,
  each: ns,
  attr: us,
  style: hs,
  property: ms,
  classed: _s,
  text: Ss,
  html: Ms,
  raise: zs,
  lower: As,
  append: Bs,
  insert: Is,
  remove: Rs,
  clone: Vs,
  datum: Fs,
  on: Ws,
  dispatch: qs,
  [Symbol.iterator]: Qs
};
function me(e) {
  return typeof e == "string" ? new pe([[document.querySelector(e)]], [document.documentElement]) : new pe([[e]], Ti);
}
function Js(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function we(e, t) {
  if (e = Js(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const el = { passive: !1 }, pt = { capture: !0, passive: !1 };
function vn(e) {
  e.stopImmediatePropagation();
}
function et(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Ii(e) {
  var t = e.document.documentElement, n = me(e).on("dragstart.drag", et, pt);
  "onselectstart" in t ? n.on("selectstart.drag", et, pt) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Di(e, t) {
  var n = e.document.documentElement, o = me(e).on("dragstart.drag", null);
  t && (o.on("click.drag", et, pt), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const Mt = (e) => () => e;
function On(e, {
  sourceEvent: t,
  subject: n,
  target: o,
  identifier: i,
  active: r,
  x: a,
  y: s,
  dx: l,
  dy: u,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: r, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: s, enumerable: !0, configurable: !0 },
    dx: { value: l, enumerable: !0, configurable: !0 },
    dy: { value: u, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
On.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function tl(e) {
  return !e.ctrlKey && !e.button;
}
function nl() {
  return this.parentNode;
}
function ol(e, t) {
  return t == null ? { x: e.x, y: e.y } : t;
}
function il() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function rl() {
  var e = tl, t = nl, n = ol, o = il, i = {}, r = sn("start", "drag", "end"), a = 0, s, l, u, c, f = 0;
  function d(y) {
    y.on("mousedown.drag", w).filter(o).on("touchstart.drag", _).on("touchmove.drag", v, el).on("touchend.drag touchcancel.drag", b).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function w(y, M) {
    if (!(c || !e.call(this, y, M))) {
      var p = S(this, t.call(this, y, M), y, M, "mouse");
      !p || (me(y.view).on("mousemove.drag", g, pt).on("mouseup.drag", h, pt), Ii(y.view), vn(y), u = !1, s = y.clientX, l = y.clientY, p("start", y));
    }
  }
  function g(y) {
    if (et(y), !u) {
      var M = y.clientX - s, p = y.clientY - l;
      u = M * M + p * p > f;
    }
    i.mouse("drag", y);
  }
  function h(y) {
    me(y.view).on("mousemove.drag mouseup.drag", null), Di(y.view, u), et(y), i.mouse("end", y);
  }
  function _(y, M) {
    if (!!e.call(this, y, M)) {
      var p = y.changedTouches, O = t.call(this, y, M), R = p.length, D, I;
      for (D = 0; D < R; ++D)
        (I = S(this, O, y, M, p[D].identifier, p[D])) && (vn(y), I("start", y, p[D]));
    }
  }
  function v(y) {
    var M = y.changedTouches, p = M.length, O, R;
    for (O = 0; O < p; ++O)
      (R = i[M[O].identifier]) && (et(y), R("drag", y, M[O]));
  }
  function b(y) {
    var M = y.changedTouches, p = M.length, O, R;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), O = 0; O < p; ++O)
      (R = i[M[O].identifier]) && (vn(y), R("end", y, M[O]));
  }
  function S(y, M, p, O, R, D) {
    var I = r.copy(), G = we(D || p, M), Z, j, m;
    if ((m = n.call(y, new On("beforestart", {
      sourceEvent: p,
      target: d,
      identifier: R,
      active: a,
      x: G[0],
      y: G[1],
      dx: 0,
      dy: 0,
      dispatch: I
    }), O)) != null)
      return Z = m.x - G[0] || 0, j = m.y - G[1] || 0, function A(C, B, F) {
        var P = G, k;
        switch (C) {
          case "start":
            i[R] = A, k = a++;
            break;
          case "end":
            delete i[R], --a;
          case "drag":
            G = we(F || B, M), k = a;
            break;
        }
        I.call(
          C,
          y,
          new On(C, {
            sourceEvent: B,
            subject: m,
            target: d,
            identifier: R,
            active: k,
            x: G[0] + Z,
            y: G[1] + j,
            dx: G[0] - P[0],
            dy: G[1] - P[1],
            dispatch: I
          }),
          O
        );
      };
  }
  return d.filter = function(y) {
    return arguments.length ? (e = typeof y == "function" ? y : Mt(!!y), d) : e;
  }, d.container = function(y) {
    return arguments.length ? (t = typeof y == "function" ? y : Mt(y), d) : t;
  }, d.subject = function(y) {
    return arguments.length ? (n = typeof y == "function" ? y : Mt(y), d) : n;
  }, d.touchable = function(y) {
    return arguments.length ? (o = typeof y == "function" ? y : Mt(!!y), d) : o;
  }, d.on = function() {
    var y = r.on.apply(r, arguments);
    return y === r ? d : y;
  }, d.clickDistance = function(y) {
    return arguments.length ? (f = (y = +y) * y, d) : Math.sqrt(f);
  }, d;
}
function Ri(e) {
  const t = Vt(), n = t.run(() => {
    const o = ue(), i = N(o, "snapToGrid"), r = N(o, "snapGrid"), a = N(o, "noDragClassName"), s = N(o, "nodes"), l = N(o, "nodeExtent"), u = N(o, "getNode"), c = N(o, "multiSelectionActive"), f = N(o, "nodesSelectionActive"), d = N(o, "selectNodesOnDrag"), w = N(o, "removeSelectedElements"), g = N(o, "addSelectedNodes"), h = N(o, "updateNodePositions"), _ = e, v = N(_, "onStart"), b = N(_, "onDrag"), S = N(_, "onStop"), y = N(_, "el"), M = N(_, "disabled", !1), p = N(_, "id"), O = ie(!1);
    let R = ie(), D = ie({ x: void 0, y: void 0 }), I = ie();
    const G = ma();
    return le([() => M.value, () => y.value], () => {
      if (y.value) {
        const Z = me(y.value), j = p.value ? u.value(p.value) : void 0;
        M.value ? Z.on(".drag", null) : (I.value = rl().on("start", (m) => {
          !d.value && !c.value && p.value && (j != null && j.selected || w.value()), j && !M.value && d.value && kn(j, c.value, g.value, w.value, f);
          const A = G(m, i.value ? r.value : void 0);
          if (R.value = ha(s.value, A, u.value, p.value), v.value && R.value) {
            const [C, B] = gn({
              id: p.value,
              dragItems: R.value,
              getNode: u
            });
            v.value(m.sourceEvent, C, B);
          }
        }).on("drag", (m) => {
          const A = G(m, i.value ? r.value : void 0);
          let C = !1;
          if ((D.value.x !== A.x || D.value.y !== A.y) && R.value) {
            if (D.value = A, R.value = R.value.map((B) => {
              const F = { x: A.x - B.distance.x, y: A.y - B.distance.y };
              if (i.value && r.value) {
                const [k, L] = r.value;
                F.x = k * Math.round(F.x / k), F.y = L * Math.round(F.y / L);
              }
              const { position: P } = Wt(
                B,
                F,
                l.value,
                B.parentNode ? u.value(B.parentNode) : void 0
              );
              return C = C || B.position.x !== F.x || B.position.y !== F.y, B.position = P, B;
            }), !C)
              return;
            if (h.value(R.value, !0, !0), b.value) {
              const [B, F] = gn({
                id: p.value,
                dragItems: R.value,
                getNode: u
              });
              O.value = !0, b.value(m.sourceEvent, B, F);
            }
          }
          m.on("end", (B) => {
            if (O.value = !1, S.value && R.value) {
              h.value(R.value, !1, !1);
              const [F, P] = gn({
                id: p.value,
                dragItems: R.value,
                getNode: u
              });
              O.value = !1, S.value(B.sourceEvent, F, P);
            }
          });
        }).on("end", () => {
          O.value = !1;
        }).filter((m) => {
          const A = m.target;
          return !m.button && (!a.value || !Eo(A, `.${a.value}`, y) && (!(j != null && j.dragHandle) || Eo(A, j.dragHandle, y)));
        }), Z.call(I.value));
      }
    }), O;
  });
  return _t(() => t.stop()), n;
}
function zn(e) {
  var i, r;
  const t = ((r = (i = e.composedPath) == null ? void 0 : i.call(e)) == null ? void 0 : r[0]) || e.target;
  if (e.ctrlKey || e.metaKey || e.shiftKey)
    return !1;
  const n = Pe(t.hasAttribute) ? t.hasAttribute("contenteditable") : !1, o = Pe(t.closest) ? t.closest(".nokey") : null;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(t == null ? void 0 : t.nodeName) || n || !!o;
}
const vt = (e, t) => {
  const n = bt();
  let o = ie(z(e) === !0);
  return le(o, () => {
    t && typeof t == "function" && t(o.value);
  }), ni(() => {
    const i = z(e);
    if (Nr(i)) {
      o.value = i;
      return;
    }
    i && (vo(
      i,
      (r) => {
        zn(r) || (r.preventDefault(), o.value = !0);
      },
      { eventName: "keydown" }
    ), vo(
      i,
      (r) => {
        zn(r) || (r.preventDefault(), o.value = !1);
      },
      { eventName: "keyup" }
    ));
  }), typeof n.addEventListener < "u" && Fn(n, "blur", () => {
    o.value = !1;
  }), o;
}, Hi = "vue-flow__node-desc", Li = "vue-flow__edge-desc", al = "react-flow__aria-live", Vi = ["Enter", " ", "Escape"], tt = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, sl = ["tabIndex", "role", "aria-describedby", "aria-label", "data-id"], ll = {
  name: "Node",
  inheritAttrs: !1
}, ul = /* @__PURE__ */ ce({
  ...ll,
  props: {
    id: null,
    draggable: { type: Boolean },
    selectable: { type: Boolean },
    connectable: null,
    focusable: { type: Boolean },
    type: { type: [null, Function, Object, Boolean] },
    name: null,
    node: null,
    resizeObserver: null
  },
  setup(e) {
    const t = ti(e, ["id", "type", "name", "draggable", "selectable", "connectable"]);
    ot(yi, e.id);
    const n = ue(), o = N(n, "id"), i = N(n, "edges"), r = N(n, "noPanClassName"), a = N(n, "selectNodesOnDrag"), s = N(n, "nodesSelectionActive"), l = N(n, "multiSelectionActive"), u = N(n, "emits"), c = N(n, "getNode"), f = N(n, "removeSelectedElements"), d = N(n, "addSelectedNodes"), w = N(n, "updateNodeDimensions"), g = N(n, "onUpdateNodeInternals"), h = N(n, "getIntersectingNodes"), _ = N(n, "getNodeTypes"), v = N(n, "nodeExtent"), b = N(n, "elevateNodesOnSelect"), S = N(n, "disableKeyboardA11y"), y = N(n, "ariaLiveMessage"), M = Ni(), p = gt(t, "node"), O = ne(() => p.value.parentNode ? c.value(p.value.parentNode) : void 0), R = ne(() => rn([p.value], i.value)), D = ie();
    ot(xi, D);
    const { emit: I, on: G } = pa(p.value, u.value), Z = Ri({
      id: e.id,
      el: D,
      disabled: ne(() => !e.draggable),
      onStart($, Y, U) {
        I.dragStart({ event: $, node: Y, nodes: U, intersections: h.value(Y) });
      },
      onDrag($, Y, U) {
        I.drag({ event: $, node: Y, nodes: U, intersections: h.value(Y) });
      },
      onStop($, Y, U) {
        I.dragStop({ event: $, node: Y, nodes: U, intersections: h.value(Y) });
      }
    }), j = ne(() => p.value.class instanceof Function ? p.value.class(p.value) : p.value.class), m = ne(() => {
      const $ = (p.value.style instanceof Function ? p.value.style(p.value) : p.value.style) || {}, Y = p.value.width instanceof Function ? p.value.width(p.value) : p.value.width, U = p.value.height instanceof Function ? p.value.height(p.value) : p.value.height;
      return Y && ($.width = typeof Y == "string" ? Y : `${Y}px`), U && ($.height = typeof U == "string" ? U : `${U}px`), $;
    });
    g.value(($) => {
      $.includes(e.id) && C();
    }), be(() => {
      t.resizeObserver.observe(D.value);
    }), Hn(() => {
      t.resizeObserver.unobserve(D.value);
    }), le(
      [() => p.value.type, () => p.value.sourcePosition, () => p.value.targetPosition],
      () => {
        w.value([{ id: e.id, nodeElement: D.value, forceUpdate: !0 }]);
      },
      { flush: "pre" }
    ), le(
      [
        () => p.value.position.x,
        () => p.value.position.y,
        () => {
          var $;
          return ($ = O.value) == null ? void 0 : $.computedPosition.x;
        },
        () => {
          var $;
          return ($ = O.value) == null ? void 0 : $.computedPosition.y;
        },
        () => {
          var $;
          return ($ = O.value) == null ? void 0 : $.computedPosition.z;
        },
        () => p.value.selected,
        () => p.value.dimensions,
        () => {
          var $;
          return ($ = O.value) == null ? void 0 : $.dimensions;
        }
      ],
      ([$, Y, U, x, E]) => {
        const H = {
          x: $,
          y: Y,
          z: (Le(m.value.zIndex) ? m.value.zIndex : 0) + (b.value && p.value.selected ? 1e3 : 0)
        };
        A(H, U && x ? { x: U, y: x, z: E || 0 } : void 0);
      },
      { flush: "pre", immediate: !0 }
    );
    function A($, Y) {
      let U = $;
      Y && (U = na({ x: Y.x, y: Y.y, z: Y.z }, $)), p.value.computedPosition = U;
    }
    Ke(() => p.value.initialized).toBe(!0).then(() => {
      const { position: $ } = Wt(p.value, p.value.computedPosition, v.value, O.value);
      p.value.computedPosition = { ...p.value.computedPosition, ...$ };
    });
    function C() {
      D.value && w.value([{ id: e.id, nodeElement: D.value, forceUpdate: !0 }]);
      const { position: $ } = Wt(p.value, p.value.position, v.value, O.value);
      p.value.position = $;
    }
    function B($) {
      Z != null && Z.value || I.mouseEnter({ event: $, node: p.value, connectedEdges: R.value });
    }
    function F($) {
      Z != null && Z.value || I.mouseMove({ event: $, node: p.value, connectedEdges: R.value });
    }
    function P($) {
      Z != null && Z.value || I.mouseLeave({ event: $, node: p.value, connectedEdges: R.value });
    }
    function k($) {
      return I.contextMenu({ event: $, node: p.value, connectedEdges: R.value });
    }
    function L($) {
      return I.doubleClick({ event: $, node: p.value, connectedEdges: R.value });
    }
    function K($) {
      e.selectable && (!a.value || !e.draggable) && kn(p.value, l.value, d.value, f.value, s), I.click({ event: $, node: p.value, connectedEdges: R.value });
    }
    const oe = ($) => {
      var Y;
      if (!zn($))
        if ($.preventDefault(), Vi.includes($.key) && e.selectable) {
          const U = $.key === "Escape";
          U && ((Y = D.value) == null || Y.blur()), kn(p.value, l.value, d.value, f.value, s, U);
        } else
          !S.value && e.draggable && p.value.selected && tt[$.key] && (y.value = `Moved selected node ${$.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~p.value.position.x}, y: ${~~p.value.position.y}`, M(
            {
              x: tt[$.key].x,
              y: tt[$.key].y
            },
            $.shiftKey
          ));
    };
    return ($, Y) => {
      var U;
      return te(), re("div", {
        ref_key: "nodeElement",
        ref: D,
        class: Oe(["vue-flow__node", [
          `vue-flow__node-${e.type === !1 ? "default" : e.name}`,
          r.value,
          {
            dragging: z(Z),
            selected: p.value.selected,
            selectable: e.selectable
          },
          z(j)
        ]]),
        style: ze({
          zIndex: (U = p.value.computedPosition.z) != null ? U : 0,
          transform: `translate(${p.value.computedPosition.x}px,${p.value.computedPosition.y}px)`,
          pointerEvents: e.selectable || e.draggable ? "all" : "none",
          ...z(m)
        }),
        tabIndex: e.focusable ? 0 : void 0,
        role: e.focusable ? "button" : void 0,
        "aria-describedby": S.value ? void 0 : `${z(Hi)}-${o.value}`,
        "aria-label": p.value.ariaLabel,
        "data-id": p.value.id,
        onMouseenter: B,
        onMousemove: F,
        onMouseleave: P,
        onContextmenu: k,
        onClick: K,
        onDblclick: L,
        onKeydown: oe
      }, [
        (te(), Ne(Ln(e.type === !1 ? _.value.default : e.type), {
          id: p.value.id,
          type: p.value.type,
          data: p.value.data,
          events: { ...p.value.events, ...z(G) },
          selected: !!p.value.selected,
          resizing: !!p.value.resizing,
          dragging: z(Z),
          connectable: e.connectable,
          position: p.value.position,
          dimensions: p.value.dimensions,
          "is-valid-target-pos": p.value.isValidTargetPos,
          "is-valid-source-pos": p.value.isValidSourcePos,
          "parent-node": p.value.parentNode,
          "z-index": p.value.computedPosition.z,
          "target-position": p.value.targetPosition,
          "source-position": p.value.sourcePosition,
          label: p.value.label,
          "drag-handle": p.value.dragHandle,
          onUpdateNodeInternals: C
        }, null, 40, ["id", "type", "data", "events", "selected", "resizing", "dragging", "connectable", "position", "dimensions", "is-valid-target-pos", "is-valid-source-pos", "parent-node", "z-index", "target-position", "source-position", "label", "drag-handle"]))
      ], 46, sl);
    };
  }
}), cl = ["transform"], dl = ["width", "height", "x", "y", "rx", "ry"], fl = ["y"], hl = {
  name: "EdgeText"
}, gl = /* @__PURE__ */ ce({
  ...hl,
  props: {
    x: null,
    y: null,
    label: null,
    labelStyle: { default: () => ({}) },
    labelShowBg: { type: Boolean, default: !0 },
    labelBgStyle: { default: () => ({}) },
    labelBgPadding: { default: () => [2, 4] },
    labelBgBorderRadius: { default: 2 }
  },
  setup(e) {
    let t = ie({ x: 0, y: 0, width: 0, height: 0 });
    const n = ie(null), o = () => {
      if (!n.value)
        return;
      const r = n.value.getBBox();
      (r.width !== t.value.width || r.height !== t.value.height) && (t.value = r);
    };
    be(o), le([() => e.x, () => e.y, n, () => e.label], o);
    const i = ne(() => `translate(${e.x - t.value.width / 2} ${e.y - t.value.height / 2})`);
    return (r, a) => (te(), re("g", {
      transform: z(i),
      class: "vue-flow__edge-textwrapper"
    }, [
      e.labelShowBg ? (te(), re("rect", {
        key: 0,
        class: "vue-flow__edge-textbg",
        width: `${t.value.width + 2 * e.labelBgPadding[0]}px`,
        height: `${t.value.height + 2 * e.labelBgPadding[1]}px`,
        x: -e.labelBgPadding[0],
        y: -e.labelBgPadding[1],
        style: ze(e.labelBgStyle),
        rx: e.labelBgBorderRadius,
        ry: e.labelBgBorderRadius
      }, null, 12, dl)) : Ee("", !0),
      it("text", oi(r.$attrs, {
        ref_key: "el",
        ref: n,
        class: "vue-flow__edge-text",
        y: t.value.height / 2,
        dy: "0.3em",
        style: e.labelStyle
      }), [
        ve(r.$slots, "default", {}, () => [
          z(Ie)(e.label) ? (te(), re(Me, { key: 1 }, [
            vr(Nn(e.label), 1)
          ], 64)) : (te(), Ne(Ln(e.label), { key: 0 }))
        ])
      ], 16, fl)
    ], 8, cl));
  }
}), Jn = function({
  path: e,
  label: t,
  labelX: n,
  labelY: o,
  labelBgBorderRadius: i,
  labelBgPadding: r,
  labelBgStyle: a,
  labelShowBg: s = !0,
  labelStyle: l,
  markerStart: u,
  markerEnd: c,
  interactionWidth: f = 20
}, { attrs: d }) {
  return [
    ae("path", {
      style: d.style,
      class: ["vue-flow__edge-path", d.class].join(" "),
      d: e,
      "marker-end": c,
      "marker-start": u
    }),
    f ? ae("path", {
      d: e,
      fill: "none",
      "stroke-opacity": 0,
      "stroke-width": f
    }) : null,
    t && Le(n) && Le(o) ? ae(gl, {
      x: n,
      y: o,
      label: t,
      labelStyle: l,
      labelShowBg: s,
      labelBgStyle: a,
      labelBgPadding: r,
      labelBgBorderRadius: i
    }) : null
  ];
};
Jn.props = [
  "path",
  "labelX",
  "labelY",
  "label",
  "labelBgBorderRadius",
  "labelBgPadding",
  "labelBgStyle",
  "labelShowBg",
  "labelStyle",
  "markerStart",
  "markerEnd",
  "interactionWidth"
];
Jn.inheritAttrs = !1;
const un = Jn;
function Fi({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const i = Math.abs(n - e) / 2, r = n < e ? n + i : n - i, a = Math.abs(o - t) / 2, s = o < t ? o + a : o - a;
  return [r, s, i, a];
}
function Yi({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o,
  sourceControlX: i,
  sourceControlY: r,
  targetControlX: a,
  targetControlY: s
}) {
  const l = e * 0.125 + i * 0.375 + a * 0.375 + n * 0.125, u = t * 0.125 + r * 0.375 + s * 0.375 + o * 0.125, c = Math.abs(l - e), f = Math.abs(u - t);
  return [l, u, c, f];
}
function Ot(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function ko({ pos: e, x1: t, y1: n, x2: o, y2: i, c: r }) {
  let a, s;
  switch (e) {
    case q.Left:
      a = t - Ot(t - o, r), s = n;
      break;
    case q.Right:
      a = t + Ot(o - t, r), s = n;
      break;
    case q.Top:
      a = t, s = n - Ot(n - i, r);
      break;
    case q.Bottom:
      a = t, s = n + Ot(i - n, r);
      break;
  }
  return [a, s];
}
function Xi({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top,
  curvature: a = 0.25
}) {
  const [s, l] = ko({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i,
    c: a
  }), [u, c] = ko({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t,
    c: a
  }), [f, d, w, g] = Yi({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: s,
    sourceControlY: l,
    targetControlX: u,
    targetControlY: c
  });
  return [
    `M${e},${t} C${s},${l} ${u},${c} ${o},${i}`,
    f,
    d,
    w,
    g
  ];
}
const eo = function({ sourcePosition: e = q.Bottom, targetPosition: t = q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Xi({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return ae(un, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
eo.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "curvature",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
eo.inheritAttrs = !1;
const vl = eo;
function Mo({ pos: e, x1: t, y1: n, x2: o, y2: i }) {
  let r, a;
  switch (e) {
    case q.Left:
    case q.Right:
      r = 0.5 * (t + o), a = n;
      break;
    case q.Top:
    case q.Bottom:
      r = t, a = 0.5 * (n + i);
      break;
  }
  return [r, a];
}
function Zi({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top
}) {
  const [a, s] = Mo({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i
  }), [l, u] = Mo({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t
  }), [c, f, d, w] = Yi({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: a,
    sourceControlY: s,
    targetControlX: l,
    targetControlY: u
  });
  return [
    `M${e},${t} C${a},${s} ${l},${u} ${o},${i}`,
    c,
    f,
    d,
    w
  ];
}
const to = function({ sourcePosition: e = q.Bottom, targetPosition: t = q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Zi({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return ae(un, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
to.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
to.inheritAttrs = !1;
const pl = to, Oo = {
  [q.Left]: { x: -1, y: 0 },
  [q.Right]: { x: 1, y: 0 },
  [q.Top]: { x: 0, y: -1 },
  [q.Bottom]: { x: 0, y: 1 }
}, ml = ({
  source: e,
  sourcePosition: t = q.Bottom,
  target: n
}) => t === q.Left || t === q.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, zo = (e, t) => Math.sqrt((t.x - e.x) ** 2 + (t.y - e.y) ** 2);
function yl({
  source: e,
  sourcePosition: t = q.Bottom,
  target: n,
  targetPosition: o = q.Top,
  center: i,
  offset: r
}) {
  const a = Oo[t], s = Oo[o], l = { x: e.x + a.x * r, y: e.y + a.y * r }, u = { x: n.x + s.x * r, y: n.y + s.y * r }, c = ml({
    source: l,
    sourcePosition: t,
    target: u
  }), f = c.x !== 0 ? "x" : "y", d = c[f];
  let w = [], g, h;
  const [_, v, b, S] = Fi({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (a[f] * s[f] === -1) {
    g = i.x || _, h = i.y || v;
    const M = [
      { x: g, y: l.y },
      { x: g, y: u.y }
    ], p = [
      { x: l.x, y: h },
      { x: u.x, y: h }
    ];
    a[f] === d ? w = f === "x" ? M : p : w = f === "x" ? p : M;
  } else {
    const M = [{ x: l.x, y: u.y }], p = [{ x: u.x, y: l.y }];
    if (f === "x" ? w = a.x === d ? p : M : w = a.y === d ? M : p, t !== o) {
      const O = f === "x" ? "y" : "x", R = a[f] === s[O], D = l[O] > u[O], I = l[O] < u[O];
      (a[f] === 1 && (!R && D || R && I) || a[f] !== 1 && (!R && I || R && D)) && (w = f === "x" ? M : p);
    }
    g = w[0].x, h = w[0].y;
  }
  return [[e, l, ...w, u, n], g, h, b, S];
}
function xl(e, t, n, o) {
  const i = Math.min(zo(e, t) / 2, zo(t, n) / 2, o), { x: r, y: a } = t;
  if (e.x === r && r === n.x || e.y === a && a === n.y)
    return `L${r} ${a}`;
  if (e.y === a) {
    const u = e.x < n.x ? -1 : 1, c = e.y < n.y ? 1 : -1;
    return `L ${r + i * u},${a}Q ${r},${a} ${r},${a + i * c}`;
  }
  const s = e.x < n.x ? 1 : -1, l = e.y < n.y ? -1 : 1;
  return `L ${r},${a + i * l}Q ${r},${a} ${r + i * s},${a}`;
}
function Pn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = q.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = q.Top,
  borderRadius: a = 5,
  centerX: s,
  centerY: l,
  offset: u = 20
}) {
  const [c, f, d, w, g] = yl({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: i },
    targetPosition: r,
    center: { x: s, y: l },
    offset: u
  });
  return [c.reduce((_, v, b) => {
    let S = "";
    return b > 0 && b < c.length - 1 ? S = xl(c[b - 1], v, c[b + 1], a) : S = `${b === 0 ? "M" : "L"}${v.x} ${v.y}`, _ += S, _;
  }, ""), f, d, w, g];
}
const no = function({ sourcePosition: e = q.Bottom, targetPosition: t = q.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Pn({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return ae(un, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
no.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "borderRadius",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
no.inheritAttrs = !1;
const Ki = no, oo = function(e, { attrs: t }) {
  return ae(Ki, { ...e, ...t, borderRadius: 0 });
};
oo.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
oo.inheritAttrs = !1;
const wl = oo;
function _l({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const [i, r, a, s] = Fi({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o
  });
  return [`M ${e},${t}L ${n},${o}`, i, r, a, s];
}
const io = function(e, { attrs: t }) {
  const [n, o, i] = _l(e);
  return ae(un, {
    path: n,
    labelX: o,
    labelY: i,
    ...e,
    ...t
  });
};
io.props = [
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
io.inheritAttrs = !1;
const bl = io, Nl = (e, t, n) => n === q.Left ? e - t : n === q.Right ? e + t : e, El = (e, t, n) => n === q.Top ? e - t : n === q.Bottom ? e + t : e, Wi = function({ radius: e = 10, centerX: t = 0, centerY: n = 0, position: o = q.Top }) {
  const i = () => {
    const a = Nl(t, e, o);
    return isNaN(a) ? 0 : a;
  }, r = () => {
    const a = El(n, e, o);
    return isNaN(a) ? 0 : a;
  };
  return ae("circle", {
    class: "vue-flow__edgeupdater",
    cx: i(),
    cy: r(),
    r: e,
    stroke: "transparent",
    fill: "transparent"
  });
};
Wi.props = ["radius", "centerX", "centerY", "position"];
const Po = Wi, Sl = () => ({
  doubleClick: X(),
  click: X(),
  mouseEnter: X(),
  mouseMove: X(),
  mouseLeave: X(),
  contextMenu: X(),
  updateStart: X(),
  update: X(),
  updateEnd: X()
});
function Cl(e, t) {
  const n = Sl();
  return n.doubleClick.on((o) => {
    var i, r;
    t.edgeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.edgeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.edgeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.edgeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.edgeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.edgeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.updateStart.on((o) => {
    var i, r;
    t.edgeUpdateStart(o), (r = (i = e.events) == null ? void 0 : i.updateStart) == null || r.call(i, o);
  }), n.update.on((o) => {
    var i, r;
    t.edgeUpdate(o), (r = (i = e.events) == null ? void 0 : i.update) == null || r.call(i, o);
  }), n.updateEnd.on((o) => {
    var i, r;
    t.edgeUpdateEnd(o), (r = (i = e.events) == null ? void 0 : i.updateEnd) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
const Ao = (e, t, n) => {
  var s, l, u, c;
  const o = ((s = n == null ? void 0 : n.x) != null ? s : 0) + t.x, i = ((l = n == null ? void 0 : n.y) != null ? l : 0) + t.y, r = (u = n == null ? void 0 : n.width) != null ? u : t.width, a = (c = n == null ? void 0 : n.height) != null ? c : t.height;
  switch (e) {
    case q.Top:
      return {
        x: o + r / 2,
        y: i
      };
    case q.Right:
      return {
        x: o + r,
        y: i + a / 2
      };
    case q.Bottom:
      return {
        x: o + r / 2,
        y: i + a
      };
    case q.Left:
      return {
        x: o,
        y: i + a / 2
      };
  }
}, Bo = (e = [], t) => {
  if (!e.length)
    return;
  let n;
  return !t && e.length === 1 ? n = e[0] : t && (n = e.find((o) => o.id === t)), n || e[0];
}, $l = (e, t, n, o, i, r) => {
  const a = Ao(
    n,
    {
      ...e.dimensions,
      ...e.computedPosition
    },
    t
  ), s = Ao(
    r,
    {
      ...o.dimensions,
      ...o.computedPosition
    },
    i
  );
  return {
    sourceX: a.x,
    sourceY: a.y,
    targetX: s.x,
    targetY: s.y
  };
};
function kl({
  sourcePos: e,
  targetPos: t,
  sourceWidth: n,
  sourceHeight: o,
  targetWidth: i,
  targetHeight: r,
  width: a,
  height: s,
  viewport: l
}) {
  const u = {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x + n, t.x + i),
    y2: Math.max(e.y + o, t.y + r)
  };
  u.x === u.x2 && (u.x2 += 1), u.y === u.y2 && (u.y2 += 1);
  const c = Xt({
    x: (0 - l.x) / l.zoom,
    y: (0 - l.y) / l.zoom,
    width: a / l.zoom,
    height: s / l.zoom
  }), f = Math.max(0, Math.min(c.x2, u.x2) - Math.max(c.x, u.x)), d = Math.max(0, Math.min(c.y2, u.y2) - Math.max(c.y, u.y));
  return Math.ceil(f * d) > 0;
}
const Ml = (e, t) => {
  let n = -1;
  const o = e.reduce((i, r) => {
    const a = t(r.source), s = t(r.target);
    if (!a || !s)
      return i;
    const l = r.z ? r.z : Math.max(a.computedPosition.z || 0, s.computedPosition.z || 0);
    return i[l] ? i[l].push(r) : i[l] = [r], n = l > n ? l : n, i;
  }, {});
  return Object.entries(Object.keys(o).length ? o : { 0: [] }).map(([i, r]) => {
    const a = +i;
    return {
      edges: r,
      level: a,
      isMaxLevel: a === n
    };
  });
}, Ol = ce({
  props: ["name", "type", "id", "updatable", "selectable", "focusable", "edge", "sourceNode", "targetNode"],
  setup(e) {
    const {
      id: t,
      addSelectedEdges: n,
      connectionMode: o,
      edgeUpdaterRadius: i,
      emits: r,
      nodesSelectionActive: a,
      getEdges: s,
      getEdgeTypes: l,
      removeSelectedEdges: u,
      findEdge: c
    } = ue(), f = Cl(e.edge, r), d = gt(e, "edge");
    let w = ie(!1), g = ie(!1);
    const h = ie(""), _ = ie(null), v = ie("source"), b = ie("source"), S = ie(), y = ie();
    ot(wi, e.id), ot(_i, y);
    const M = () => w.value = !0, p = () => w.value = !1, O = (k) => {
      Kn(k, s.value) || f.emit.update({ edge: d.value, connection: k });
    }, R = () => {
      !S.value || (f.emit.updateEnd({ event: S.value, edge: d.value }), g.value = !1);
    }, { onMouseDown: D } = bi({
      nodeId: h,
      handleId: _,
      type: v,
      isValidConnection: void 0,
      elementEdgeUpdaterType: b,
      onEdgeUpdate: O,
      onEdgeUpdateEnd: R
    }), I = (k, L) => {
      var K;
      h.value = L ? d.value.target : d.value.source, _.value = (K = L ? d.value.targetHandle : d.value.sourceHandle) != null ? K : "", v.value = L ? "target" : "source", b.value = v.value, S.value = k, f.emit.updateStart({ event: k, edge: d.value }), D(k);
    }, G = (k) => {
      const L = { event: k, edge: d.value };
      e.selectable && (a.value = !1, n([d.value])), f.emit.click(L);
    }, Z = (k) => f.emit.contextMenu({ event: k, edge: d.value }), j = (k) => f.emit.doubleClick({ event: k, edge: d.value }), m = (k) => f.emit.mouseEnter({ event: k, edge: d.value }), A = (k) => f.emit.mouseMove({ event: k, edge: d.value }), C = (k) => f.emit.mouseLeave({ event: k, edge: d.value }), B = (k) => {
      g.value = !0, I(k, !0);
    }, F = (k) => {
      g.value = !0, I(k, !1);
    }, P = (k) => {
      var L;
      Vi.includes(k.key) && e.selectable && (k.key === "Escape" ? ((L = y.value) == null || L.blur(), u([c(e.id)])) : n([c(e.id)]));
    };
    return () => {
      if (!e.sourceNode || !e.targetNode)
        return null;
      let k;
      o.value === at.Strict ? k = e.sourceNode.handleBounds.source : k = [...e.sourceNode.handleBounds.source || [], ...e.sourceNode.handleBounds.target || []];
      const L = Bo(k, d.value.sourceHandle);
      let K;
      o.value === at.Strict ? K = e.targetNode.handleBounds.target : K = [...e.targetNode.handleBounds.target || [], ...e.targetNode.handleBounds.source || []];
      const oe = Bo(K, d.value.targetHandle), $ = L ? L.position : q.Bottom, Y = oe ? oe.position : q.Top, { sourceX: U, sourceY: x, targetY: E, targetX: H } = $l(
        e.sourceNode,
        L,
        $,
        e.targetNode,
        oe,
        Y
      ), V = d.value.class instanceof Function ? d.value.class(d.value) : d.value.class, Q = d.value.style instanceof Function ? d.value.style(d.value) : d.value.style;
      return ae(
        "g",
        {
          ref: y,
          "data-id": e.id,
          class: [
            "vue-flow__edge",
            `vue-flow__edge-${e.type === !1 ? "default" : e.name}`,
            V,
            {
              updating: w.value,
              selected: d.value.selected,
              animated: d.value.animated,
              inactive: !e.selectable
            }
          ],
          onClick: G,
          onContextmenu: Z,
          onDblclick: j,
          onMouseenter: m,
          onMousemove: A,
          onMouseleave: C,
          onKeyDown: e.focusable ? P : void 0,
          tabIndex: e.focusable ? 0 : void 0,
          "aria-label": d.value.ariaLabel === null ? void 0 : d.value.ariaLabel || `Edge from ${d.value.source} to ${d.value.target}`,
          "aria-describedby": e.focusable ? `${Li}-${t}` : void 0,
          role: e.focusable ? "button" : void 0
        },
        [
          g.value ? null : ae(e.type === !1 ? l.value.default : e.type, {
            id: e.id,
            sourceNode: e.sourceNode,
            targetNode: e.targetNode,
            source: d.value.source,
            target: d.value.target,
            type: d.value.type,
            updatable: e.updatable,
            selected: d.value.selected,
            animated: d.value.animated,
            label: d.value.label,
            labelStyle: d.value.labelStyle,
            labelShowBg: d.value.labelShowBg,
            labelBgStyle: d.value.labelBgStyle,
            labelBgPadding: d.value.labelBgPadding,
            labelBgBorderRadius: d.value.labelBgBorderRadius,
            data: d.value.data,
            events: { ...d.value.events, ...f.on },
            style: Q,
            markerStart: `url(#${Ve(d.value.markerStart, t)})`,
            markerEnd: `url(#${Ve(d.value.markerEnd, t)})`,
            sourcePosition: $,
            targetPosition: Y,
            sourceX: U,
            sourceY: x,
            targetX: H,
            targetY: E,
            sourceHandleId: d.value.sourceHandle,
            targetHandleId: d.value.targetHandle,
            interactionWidth: d.value.interactionWidth
          }),
          [
            e.updatable === "source" || e.updatable === !0 ? [
              ae(
                "g",
                {
                  onMousedown: B,
                  onMouseenter: M,
                  onMouseout: p
                },
                ae(Po, {
                  position: $,
                  centerX: U,
                  centerY: x,
                  radius: i.value,
                  "data-type": "source"
                })
              )
            ] : null,
            e.updatable === "target" || e.updatable === !0 ? [
              ae(
                "g",
                {
                  onMousedown: F,
                  onMouseenter: M,
                  onMouseout: p
                },
                ae(Po, {
                  position: Y,
                  centerX: H,
                  centerY: E,
                  radius: i.value,
                  "data-type": "target"
                })
              )
            ] : null
          ]
        ]
      );
    };
  }
}), zl = Ol, Pl = {
  height: "0",
  width: "0"
}, Al = {
  name: "EdgeLabelRenderer"
}, yd = /* @__PURE__ */ ce({
  ...Al,
  setup(e) {
    const { viewportRef: t } = ue(), n = ne(() => {
      var o;
      return (o = t.value) == null ? void 0 : o.getElementsByClassName("vue-flow__edge-labels")[0];
    });
    return (o, i) => (te(), re("svg", null, [
      (te(), re("foreignObject", Pl, [
        (te(), Ne(pr, {
          to: z(n),
          disabled: !z(n)
        }, [
          ve(o.$slots, "default")
        ], 8, ["to", "disabled"]))
      ]))
    ]));
  }
}), Bl = { class: "vue-flow__connection" }, Tl = ["d", "marker-end", "marker-start"], Il = {
  name: "ConnectionLine"
}, Dl = /* @__PURE__ */ ce({
  ...Il,
  props: {
    sourceNode: null
  },
  setup(e) {
    var R, D, I;
    const t = ue(), n = N(t, "getNodes"), o = N(t, "connectionMode"), i = N(t, "connectionStartHandle"), r = N(t, "connectionPosition"), a = N(t, "connectionLineType"), s = N(t, "connectionLineStyle"), l = N(t, "connectionLineOptions"), u = N(t, "viewport"), c = (R = Re(an)) == null ? void 0 : R["connection-line"], f = c == null ? void 0 : c({}), d = i.value.handleId;
    i.value.nodeId;
    const w = i.value.type, g = (o.value === at.Strict ? (D = e.sourceNode.handleBounds[w]) == null ? void 0 : D.find((G) => G.id === d) : [...e.sourceNode.handleBounds.source || [], ...e.sourceNode.handleBounds.target || []].find((G) => G.id === d)) || ((I = e.sourceNode.handleBounds[w != null ? w : "source"]) == null ? void 0 : I[0]), h = g ? g.x + g.width / 2 : e.sourceNode.dimensions.width / 2, _ = g ? g.y + g.height / 2 : e.sourceNode.dimensions.height, v = e.sourceNode.computedPosition.x + h, b = e.sourceNode.computedPosition.y + _, y = (g == null ? void 0 : g.position) === q.Left || (g == null ? void 0 : g.position) === q.Right ? q.Left : q.Top, M = ne(() => (r.value.x - u.value.x) / u.value.zoom), p = ne(() => (r.value.y - u.value.y) / u.value.zoom), O = ne(() => {
      let G = `M${v},${b} ${M.value},${p.value}`;
      const Z = {
        sourceX: v,
        sourceY: b,
        sourcePosition: g == null ? void 0 : g.position,
        targetX: M.value,
        targetY: p.value,
        targetPosition: y
      };
      switch (a.value || l.value.type) {
        case Fe.Bezier:
          [G] = Xi(Z);
          break;
        case Fe.Step:
          [G] = Pn({
            ...Z,
            borderRadius: 0
          });
          break;
        case Fe.SmoothStep:
          [G] = Pn(Z);
          break;
        case Fe.SimpleBezier:
          [G] = Zi(Z);
          break;
      }
      return G;
    });
    return (G, Z) => {
      var j;
      return te(), re("g", Bl, [
        z(f) ? (te(), Ne(Ln(z(c)), mr(oi({ key: 0 }, {
          sourceX: v,
          sourceY: b,
          sourcePosition: (j = z(g)) == null ? void 0 : j.position,
          targetX: M.value,
          targetY: p.value,
          targetPosition: z(y),
          nodes: n.value,
          sourceNode: e.sourceNode,
          sourceHandle: z(g),
          markerEnd: `url(#${z(Ve)(l.value.markerEnd)})`,
          markerStart: `url(#${z(Ve)(l.value.markerStart)})`
        })), null, 16)) : (te(), re("path", {
          key: 1,
          d: z(O),
          class: Oe(["vue-flow__connection-path", l.value.class]),
          style: ze(s.value || l.value.style || {}),
          "marker-end": `url(#${z(Ve)(l.value.markerEnd)})`,
          "marker-start": `url(#${z(Ve)(l.value.markerStart)})`
        }, null, 14, Tl))
      ]);
    };
  }
}), Rl = ["tabIndex"], Hl = {
  name: "NodesSelection"
}, Ll = /* @__PURE__ */ ce({
  ...Hl,
  setup(e) {
    const t = ue(), n = N(t, "emits"), o = N(t, "viewport"), i = N(t, "getSelectedNodes"), r = N(t, "noPanClassName"), a = N(t, "disableKeyboardA11y"), s = N(t, "userSelectionActive"), l = Ni(), u = ie(), c = Ri({
      el: u,
      onStart(h, _, v) {
        n.value.selectionDragStart({ event: h, node: _, nodes: v });
      },
      onDrag(h, _, v) {
        n.value.selectionDrag({ event: h, node: _, nodes: v });
      },
      onStop(h, _, v) {
        n.value.selectionDragStop({ event: h, node: _, nodes: v });
      }
    });
    be(() => {
      var h;
      a.value || (h = u.value) == null || h.focus({ preventScroll: !0 });
    });
    const f = ne(() => vi(i.value)), d = ne(() => ({
      width: `${f.value.width}px`,
      height: `${f.value.height}px`,
      top: `${f.value.y}px`,
      left: `${f.value.x}px`
    }));
    function w(h) {
      n.value.selectionContextMenu({ event: h, nodes: i.value });
    }
    function g(h) {
      a.value || tt[h.key] && l(
        {
          x: tt[h.key].x,
          y: tt[h.key].y
        },
        h.shiftKey
      );
    }
    return (h, _) => !s.value && f.value.width && f.value.height ? (te(), re("div", {
      key: 0,
      class: Oe(["vue-flow__nodesselection vue-flow__container", r.value]),
      style: ze({ transform: `translate(${o.value.x}px,${o.value.y}px) scale(${o.value.zoom})` })
    }, [
      it("div", {
        ref_key: "el",
        ref: u,
        class: Oe([{ dragging: z(c) }, "vue-flow__nodesselection-rect"]),
        style: ze(z(d)),
        tabIndex: a.value ? void 0 : -1,
        onContextmenu: w,
        onKeydown: g
      }, null, 46, Rl)
    ], 6)) : Ee("", !0);
  }
}), Vl = /* @__PURE__ */ ce({
  __name: "UserSelection",
  setup(e) {
    const { userSelectionRect: t } = ue();
    return (n, o) => {
      var i, r, a, s;
      return te(), re("div", {
        class: "vue-flow__selection react-flow__container",
        style: ze({
          width: `${(i = z(t)) == null ? void 0 : i.width}px`,
          height: `${(r = z(t)) == null ? void 0 : r.height}px`,
          transform: `translate(${(a = z(t)) == null ? void 0 : a.x}px, ${(s = z(t)) == null ? void 0 : s.y}px)`
        })
      }, null, 4);
    };
  }
}), Fl = {
  input: da,
  default: ca,
  output: fa
}, Yl = {
  default: vl,
  straight: bl,
  step: wl,
  smoothstep: Ki,
  simplebezier: pl
}, Xl = () => ({
  vueFlowRef: null,
  viewportRef: null,
  nodes: [],
  edges: [],
  nodeTypes: {},
  edgeTypes: {},
  initialized: !1,
  dimensions: {
    width: 0,
    height: 0
  },
  viewport: { x: 0, y: 0, zoom: 1 },
  d3Zoom: null,
  d3Selection: null,
  d3ZoomHandler: null,
  minZoom: 0.5,
  maxZoom: 2,
  translateExtent: [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ],
  nodeExtent: [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ],
  selectionMode: Wn.Full,
  paneDragging: !1,
  preventScrolling: !0,
  zoomOnScroll: !0,
  zoomOnPinch: !0,
  zoomOnDoubleClick: !0,
  panOnScroll: !1,
  panOnScrollSpeed: 0.5,
  panOnScrollMode: Zt.Free,
  panOnDrag: !0,
  edgeUpdaterRadius: 10,
  onlyRenderVisibleElements: !1,
  defaultViewport: { x: 0, y: 0, zoom: 1 },
  nodesSelectionActive: !1,
  userSelectionActive: !1,
  userSelectionRect: null,
  defaultMarkerColor: "#b1b1b7",
  connectionLineStyle: {},
  connectionLineType: Fe.Bezier,
  connectionLineOptions: {
    type: Fe.Bezier,
    style: {}
  },
  connectionMode: at.Loose,
  connectionStartHandle: null,
  connectionClickStartHandle: null,
  connectionPosition: { x: NaN, y: NaN },
  connectOnClick: !0,
  snapGrid: [15, 15],
  snapToGrid: !1,
  edgesUpdatable: !1,
  edgesFocusable: !0,
  nodesFocusable: !0,
  nodesConnectable: !0,
  nodesDraggable: !0,
  elementsSelectable: !0,
  selectNodesOnDrag: !0,
  multiSelectionActive: !1,
  selectionKeyCode: "Shift",
  multiSelectionKeyCode: "Meta",
  zoomActivationKeyCode: "Meta",
  deleteKeyCode: "Backspace",
  panActivationKeyCode: "Space",
  hooks: Qr(),
  applyDefault: !0,
  autoConnect: !1,
  fitViewOnInit: !1,
  noDragClassName: "nodrag",
  noWheelClassName: "nowheel",
  noPanClassName: "nopan",
  defaultEdgeOptions: void 0,
  elevateEdgesOnSelect: !1,
  elevateNodesOnSelect: !0,
  disableKeyboardA11y: !1,
  ariaLiveMessage: "",
  __experimentalFeatures: {
    nestedFlow: !1
  },
  vueFlowVersion: "1.9.1"
});
function Gi(e) {
  const t = Xl();
  return e && Object.keys(e).forEach((n) => {
    const o = e[n];
    fe(o) && (t[n] = o);
  }), t;
}
function Zl(e) {
  const t = ne(() => e.nodes.map((h) => h.id)), n = ne(() => e.edges.map((h) => h.id)), o = ne(() => (h) => e.nodes && !t.value.length ? e.nodes.find((_) => _.id === h) : e.nodes[t.value.indexOf(h)]), i = ne(() => (h) => e.edges && !n.value.length ? e.edges.find((_) => _.id === h) : e.edges[n.value.indexOf(h)]), r = ne(() => {
    var v;
    const h = {
      ...Yl,
      ...e.edgeTypes
    }, _ = Object.keys(h);
    return (v = e.edges) == null || v.forEach((b) => b.type && !_.includes(b.type) && (h[b.type] = b.type)), h;
  }), a = ne(() => {
    var v;
    const h = {
      ...Fl,
      ...e.nodeTypes
    }, _ = Object.keys(h);
    return (v = e.nodes) == null || v.forEach((b) => b.type && !_.includes(b.type) && (h[b.type] = b.type)), h;
  }), s = ne(() => {
    const h = e.nodes.filter((_) => !_.hidden);
    return e.onlyRenderVisibleElements ? h && pi(
      h,
      {
        x: 0,
        y: 0,
        width: e.dimensions.width,
        height: e.dimensions.height
      },
      e.viewport,
      !0
    ) : h != null ? h : [];
  }), l = (h, _, v) => {
    if (_ = _ != null ? _ : o.value(h.source), v = v != null ? v : o.value(h.target), !_ || !v) {
      e.edges = e.edges.filter((b) => b.id !== h.id), he(`Orphaned edge ${h.id} removed.`);
      return;
    }
    return !h.hidden && !v.hidden && !_.hidden;
  }, u = ne(() => e.onlyRenderVisibleElements ? e.edges.filter((h) => {
    const _ = o.value(h.source), v = o.value(h.target);
    return l(h, _, v) && kl({
      sourcePos: _.computedPosition || { x: 0, y: 0 },
      targetPos: v.computedPosition || { x: 0, y: 0 },
      sourceWidth: _.dimensions.width,
      sourceHeight: _.dimensions.height,
      targetWidth: v.dimensions.width,
      targetHeight: v.dimensions.height,
      width: e.dimensions.width,
      height: e.dimensions.height,
      viewport: e.viewport
    });
  }) : e.edges.filter((h) => l(h))), c = ne(() => [...s.value, ...u.value]), f = ne(() => e.nodes.filter((h) => h.selected)), d = ne(() => e.edges.filter((h) => h.selected)), w = ne(() => {
    var h, _;
    return [
      ...(h = f.value) != null ? h : [],
      ...(_ = d.value) != null ? _ : []
    ];
  }), g = ne(() => s.value.filter((h) => h.initialized));
  return {
    getNode: o,
    getEdge: i,
    getElements: c,
    getEdgeTypes: r,
    getNodeTypes: a,
    getEdges: u,
    getNodes: s,
    getSelectedElements: w,
    getSelectedNodes: f,
    getSelectedEdges: d,
    getNodesInitialized: g
  };
}
function ro(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Ui(e, t) {
  var n = Object.create(e.prototype);
  for (var o in t)
    n[o] = t[o];
  return n;
}
function Et() {
}
var mt = 0.7, Ut = 1 / mt, nt = "\\s*([+-]?\\d+)\\s*", yt = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", _e = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Kl = /^#([0-9a-f]{3,8})$/, Wl = new RegExp(`^rgb\\(${nt},${nt},${nt}\\)$`), Gl = new RegExp(`^rgb\\(${_e},${_e},${_e}\\)$`), Ul = new RegExp(`^rgba\\(${nt},${nt},${nt},${yt}\\)$`), ql = new RegExp(`^rgba\\(${_e},${_e},${_e},${yt}\\)$`), Ql = new RegExp(`^hsl\\(${yt},${_e},${_e}\\)$`), jl = new RegExp(`^hsla\\(${yt},${_e},${_e},${yt}\\)$`), To = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
ro(Et, xt, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Io,
  formatHex: Io,
  formatHex8: Jl,
  formatHsl: eu,
  formatRgb: Do,
  toString: Do
});
function Io() {
  return this.rgb().formatHex();
}
function Jl() {
  return this.rgb().formatHex8();
}
function eu() {
  return qi(this).formatHsl();
}
function Do() {
  return this.rgb().formatRgb();
}
function xt(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Kl.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Ro(t) : n === 3 ? new ge(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? zt(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? zt(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Wl.exec(e)) ? new ge(t[1], t[2], t[3], 1) : (t = Gl.exec(e)) ? new ge(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Ul.exec(e)) ? zt(t[1], t[2], t[3], t[4]) : (t = ql.exec(e)) ? zt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Ql.exec(e)) ? Vo(t[1], t[2] / 100, t[3] / 100, 1) : (t = jl.exec(e)) ? Vo(t[1], t[2] / 100, t[3] / 100, t[4]) : To.hasOwnProperty(e) ? Ro(To[e]) : e === "transparent" ? new ge(NaN, NaN, NaN, 0) : null;
}
function Ro(e) {
  return new ge(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function zt(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new ge(e, t, n, o);
}
function tu(e) {
  return e instanceof Et || (e = xt(e)), e ? (e = e.rgb(), new ge(e.r, e.g, e.b, e.opacity)) : new ge();
}
function An(e, t, n, o) {
  return arguments.length === 1 ? tu(e) : new ge(e, t, n, o == null ? 1 : o);
}
function ge(e, t, n, o) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +o;
}
ro(ge, An, Ui(Et, {
  brighter(e) {
    return e = e == null ? Ut : Math.pow(Ut, e), new ge(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? mt : Math.pow(mt, e), new ge(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ge(Xe(this.r), Xe(this.g), Xe(this.b), qt(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ho,
  formatHex: Ho,
  formatHex8: nu,
  formatRgb: Lo,
  toString: Lo
}));
function Ho() {
  return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}`;
}
function nu() {
  return `#${Ye(this.r)}${Ye(this.g)}${Ye(this.b)}${Ye((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Lo() {
  const e = qt(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Xe(this.r)}, ${Xe(this.g)}, ${Xe(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function qt(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Xe(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ye(e) {
  return e = Xe(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Vo(e, t, n, o) {
  return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ye(e, t, n, o);
}
function qi(e) {
  if (e instanceof ye)
    return new ye(e.h, e.s, e.l, e.opacity);
  if (e instanceof Et || (e = xt(e)), !e)
    return new ye();
  if (e instanceof ye)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, o = e.b / 255, i = Math.min(t, n, o), r = Math.max(t, n, o), a = NaN, s = r - i, l = (r + i) / 2;
  return s ? (t === r ? a = (n - o) / s + (n < o) * 6 : n === r ? a = (o - t) / s + 2 : a = (t - n) / s + 4, s /= l < 0.5 ? r + i : 2 - r - i, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new ye(a, s, l, e.opacity);
}
function ou(e, t, n, o) {
  return arguments.length === 1 ? qi(e) : new ye(e, t, n, o == null ? 1 : o);
}
function ye(e, t, n, o) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +o;
}
ro(ye, ou, Ui(Et, {
  brighter(e) {
    return e = e == null ? Ut : Math.pow(Ut, e), new ye(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? mt : Math.pow(mt, e), new ye(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - o;
    return new ge(
      pn(e >= 240 ? e - 240 : e + 120, i, o),
      pn(e, i, o),
      pn(e < 120 ? e + 240 : e - 120, i, o),
      this.opacity
    );
  },
  clamp() {
    return new ye(Fo(this.h), Pt(this.s), Pt(this.l), qt(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = qt(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Fo(this.h)}, ${Pt(this.s) * 100}%, ${Pt(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Fo(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Pt(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function pn(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Qi = (e) => () => e;
function iu(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function ru(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
    return Math.pow(e + o * t, n);
  };
}
function au(e) {
  return (e = +e) == 1 ? ji : function(t, n) {
    return n - t ? ru(t, n, e) : Qi(isNaN(t) ? n : t);
  };
}
function ji(e, t) {
  var n = t - e;
  return n ? iu(e, n) : Qi(isNaN(e) ? t : e);
}
const Yo = function e(t) {
  var n = au(t);
  function o(i, r) {
    var a = n((i = An(i)).r, (r = An(r)).r), s = n(i.g, r.g), l = n(i.b, r.b), u = ji(i.opacity, r.opacity);
    return function(c) {
      return i.r = a(c), i.g = s(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return o.gamma = e, o;
}(1);
function Te(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Bn = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, mn = new RegExp(Bn.source, "g");
function su(e) {
  return function() {
    return e;
  };
}
function lu(e) {
  return function(t) {
    return e(t) + "";
  };
}
function uu(e, t) {
  var n = Bn.lastIndex = mn.lastIndex = 0, o, i, r, a = -1, s = [], l = [];
  for (e = e + "", t = t + ""; (o = Bn.exec(e)) && (i = mn.exec(t)); )
    (r = i.index) > n && (r = t.slice(n, r), s[a] ? s[a] += r : s[++a] = r), (o = o[0]) === (i = i[0]) ? s[a] ? s[a] += i : s[++a] = i : (s[++a] = null, l.push({ i: a, x: Te(o, i) })), n = mn.lastIndex;
  return n < t.length && (r = t.slice(n), s[a] ? s[a] += r : s[++a] = r), s.length < 2 ? l[0] ? lu(l[0].x) : su(t) : (t = l.length, function(u) {
    for (var c = 0, f; c < t; ++c)
      s[(f = l[c]).i] = f.x(u);
    return s.join("");
  });
}
var Xo = 180 / Math.PI, Tn = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Ji(e, t, n, o, i, r) {
  var a, s, l;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * o) && (n -= e * l, o -= t * l), (s = Math.sqrt(n * n + o * o)) && (n /= s, o /= s, l /= s), e * o < t * n && (e = -e, t = -t, l = -l, a = -a), {
    translateX: i,
    translateY: r,
    rotate: Math.atan2(t, e) * Xo,
    skewX: Math.atan(l) * Xo,
    scaleX: a,
    scaleY: s
  };
}
var At;
function cu(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Tn : Ji(t.a, t.b, t.c, t.d, t.e, t.f);
}
function du(e) {
  return e == null || (At || (At = document.createElementNS("http://www.w3.org/2000/svg", "g")), At.setAttribute("transform", e), !(e = At.transform.baseVal.consolidate())) ? Tn : (e = e.matrix, Ji(e.a, e.b, e.c, e.d, e.e, e.f));
}
function er(e, t, n, o) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function r(u, c, f, d, w, g) {
    if (u !== f || c !== d) {
      var h = w.push("translate(", null, t, null, n);
      g.push({ i: h - 4, x: Te(u, f) }, { i: h - 2, x: Te(c, d) });
    } else
      (f || d) && w.push("translate(" + f + t + d + n);
  }
  function a(u, c, f, d) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), d.push({ i: f.push(i(f) + "rotate(", null, o) - 2, x: Te(u, c) })) : c && f.push(i(f) + "rotate(" + c + o);
  }
  function s(u, c, f, d) {
    u !== c ? d.push({ i: f.push(i(f) + "skewX(", null, o) - 2, x: Te(u, c) }) : c && f.push(i(f) + "skewX(" + c + o);
  }
  function l(u, c, f, d, w, g) {
    if (u !== f || c !== d) {
      var h = w.push(i(w) + "scale(", null, ",", null, ")");
      g.push({ i: h - 4, x: Te(u, f) }, { i: h - 2, x: Te(c, d) });
    } else
      (f !== 1 || d !== 1) && w.push(i(w) + "scale(" + f + "," + d + ")");
  }
  return function(u, c) {
    var f = [], d = [];
    return u = e(u), c = e(c), r(u.translateX, u.translateY, c.translateX, c.translateY, f, d), a(u.rotate, c.rotate, f, d), s(u.skewX, c.skewX, f, d), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, f, d), u = c = null, function(w) {
      for (var g = -1, h = d.length, _; ++g < h; )
        f[(_ = d[g]).i] = _.x(w);
      return f.join("");
    };
  };
}
var fu = er(cu, "px, ", "px)", "deg)"), hu = er(du, ", ", ")", ")"), gu = 1e-12;
function Zo(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function vu(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function pu(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const mu = function e(t, n, o) {
  function i(r, a) {
    var s = r[0], l = r[1], u = r[2], c = a[0], f = a[1], d = a[2], w = c - s, g = f - l, h = w * w + g * g, _, v;
    if (h < gu)
      v = Math.log(d / u) / t, _ = function(O) {
        return [
          s + O * w,
          l + O * g,
          u * Math.exp(t * O * v)
        ];
      };
    else {
      var b = Math.sqrt(h), S = (d * d - u * u + o * h) / (2 * u * n * b), y = (d * d - u * u - o * h) / (2 * d * n * b), M = Math.log(Math.sqrt(S * S + 1) - S), p = Math.log(Math.sqrt(y * y + 1) - y);
      v = (p - M) / t, _ = function(O) {
        var R = O * v, D = Zo(M), I = u / (n * b) * (D * pu(t * R + M) - vu(M));
        return [
          s + I * w,
          l + I * g,
          u * D / Zo(t * R + M)
        ];
      };
    }
    return _.duration = v * 1e3 * t / Math.SQRT2, _;
  }
  return i.rho = function(r) {
    var a = Math.max(1e-3, +r), s = a * a, l = s * s;
    return e(a, s, l);
  }, i;
}(Math.SQRT2, 2, 4);
var lt = 0, ft = 0, ct = 0, tr = 1e3, Qt, ht, jt = 0, We = 0, cn = 0, wt = typeof performance == "object" && performance.now ? performance : Date, nr = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function ao() {
  return We || (nr(yu), We = wt.now() + cn);
}
function yu() {
  We = 0;
}
function Jt() {
  this._call = this._time = this._next = null;
}
Jt.prototype = or.prototype = {
  constructor: Jt,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? ao() : +n) + (t == null ? 0 : +t), !this._next && ht !== this && (ht ? ht._next = this : Qt = this, ht = this), this._call = e, this._time = n, In();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, In());
  }
};
function or(e, t, n) {
  var o = new Jt();
  return o.restart(e, t, n), o;
}
function xu() {
  ao(), ++lt;
  for (var e = Qt, t; e; )
    (t = We - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --lt;
}
function Ko() {
  We = (jt = wt.now()) + cn, lt = ft = 0;
  try {
    xu();
  } finally {
    lt = 0, _u(), We = 0;
  }
}
function wu() {
  var e = wt.now(), t = e - jt;
  t > tr && (cn -= t, jt = e);
}
function _u() {
  for (var e, t = Qt, n, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Qt = n);
  ht = e, In(o);
}
function In(e) {
  if (!lt) {
    ft && (ft = clearTimeout(ft));
    var t = e - We;
    t > 24 ? (e < 1 / 0 && (ft = setTimeout(Ko, e - wt.now() - cn)), ct && (ct = clearInterval(ct))) : (ct || (jt = wt.now(), ct = setInterval(wu, tr)), lt = 1, nr(Ko));
  }
}
function Wo(e, t, n) {
  var o = new Jt();
  return t = t == null ? 0 : +t, o.restart((i) => {
    o.stop(), e(i + t);
  }, t, n), o;
}
var bu = sn("start", "end", "cancel", "interrupt"), Nu = [], ir = 0, Go = 1, Dn = 2, Dt = 3, Uo = 4, Rn = 5, Rt = 6;
function dn(e, t, n, o, i, r) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  Eu(e, n, {
    name: t,
    index: o,
    group: i,
    on: bu,
    tween: Nu,
    time: r.time,
    delay: r.delay,
    duration: r.duration,
    ease: r.ease,
    timer: null,
    state: ir
  });
}
function so(e, t) {
  var n = xe(e, t);
  if (n.state > ir)
    throw new Error("too late; already scheduled");
  return n;
}
function Se(e, t) {
  var n = xe(e, t);
  if (n.state > Dt)
    throw new Error("too late; already running");
  return n;
}
function xe(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Eu(e, t, n) {
  var o = e.__transition, i;
  o[t] = n, n.timer = or(r, 0, n.time);
  function r(u) {
    n.state = Go, n.timer.restart(a, n.delay, n.time), n.delay <= u && a(u - n.delay);
  }
  function a(u) {
    var c, f, d, w;
    if (n.state !== Go)
      return l();
    for (c in o)
      if (w = o[c], w.name === n.name) {
        if (w.state === Dt)
          return Wo(a);
        w.state === Uo ? (w.state = Rt, w.timer.stop(), w.on.call("interrupt", e, e.__data__, w.index, w.group), delete o[c]) : +c < t && (w.state = Rt, w.timer.stop(), w.on.call("cancel", e, e.__data__, w.index, w.group), delete o[c]);
      }
    if (Wo(function() {
      n.state === Dt && (n.state = Uo, n.timer.restart(s, n.delay, n.time), s(u));
    }), n.state = Dn, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Dn) {
      for (n.state = Dt, i = new Array(d = n.tween.length), c = 0, f = -1; c < d; ++c)
        (w = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++f] = w);
      i.length = f + 1;
    }
  }
  function s(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = Rn, 1), f = -1, d = i.length; ++f < d; )
      i[f].call(e, c);
    n.state === Rn && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = Rt, n.timer.stop(), delete o[t];
    for (var u in o)
      return;
    delete e.__transition;
  }
}
function Ht(e, t) {
  var n = e.__transition, o, i, r = !0, a;
  if (!!n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((o = n[a]).name !== t) {
        r = !1;
        continue;
      }
      i = o.state > Dn && o.state < Rn, o.state = Rt, o.timer.stop(), o.on.call(i ? "interrupt" : "cancel", e, e.__data__, o.index, o.group), delete n[a];
    }
    r && delete e.__transition;
  }
}
function Su(e) {
  return this.each(function() {
    Ht(this, e);
  });
}
function Cu(e, t) {
  var n, o;
  return function() {
    var i = Se(this, e), r = i.tween;
    if (r !== n) {
      o = n = r;
      for (var a = 0, s = o.length; a < s; ++a)
        if (o[a].name === t) {
          o = o.slice(), o.splice(a, 1);
          break;
        }
    }
    i.tween = o;
  };
}
function $u(e, t, n) {
  var o, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var r = Se(this, e), a = r.tween;
    if (a !== o) {
      i = (o = a).slice();
      for (var s = { name: t, value: n }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === t) {
          i[l] = s;
          break;
        }
      l === u && i.push(s);
    }
    r.tween = i;
  };
}
function ku(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var o = xe(this.node(), n).tween, i = 0, r = o.length, a; i < r; ++i)
      if ((a = o[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? Cu : $u)(n, e, t));
}
function lo(e, t, n) {
  var o = e._id;
  return e.each(function() {
    var i = Se(this, o);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return xe(i, o).value[t];
  };
}
function rr(e, t) {
  var n;
  return (typeof t == "number" ? Te : t instanceof xt ? Yo : (n = xt(t)) ? (t = n, Yo) : uu)(e, t);
}
function Mu(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Ou(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function zu(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Pu(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Au(e, t, n) {
  var o, i, r;
  return function() {
    var a, s = n(this), l;
    return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = s + "", a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s)));
  };
}
function Bu(e, t, n) {
  var o, i, r;
  return function() {
    var a, s = n(this), l;
    return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = s + "", a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s)));
  };
}
function Tu(e, t) {
  var n = ln(e), o = n === "transform" ? hu : rr;
  return this.attrTween(e, typeof t == "function" ? (n.local ? Bu : Au)(n, o, lo(this, "attr." + e, t)) : t == null ? (n.local ? Ou : Mu)(n) : (n.local ? Pu : zu)(n, o, t));
}
function Iu(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Du(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Ru(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Du(e, r)), n;
  }
  return i._value = t, i;
}
function Hu(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Iu(e, r)), n;
  }
  return i._value = t, i;
}
function Lu(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var o = ln(e);
  return this.tween(n, (o.local ? Ru : Hu)(o, t));
}
function Vu(e, t) {
  return function() {
    so(this, e).delay = +t.apply(this, arguments);
  };
}
function Fu(e, t) {
  return t = +t, function() {
    so(this, e).delay = t;
  };
}
function Yu(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Vu : Fu)(t, e)) : xe(this.node(), t).delay;
}
function Xu(e, t) {
  return function() {
    Se(this, e).duration = +t.apply(this, arguments);
  };
}
function Zu(e, t) {
  return t = +t, function() {
    Se(this, e).duration = t;
  };
}
function Ku(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Xu : Zu)(t, e)) : xe(this.node(), t).duration;
}
function Wu(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Se(this, e).ease = t;
  };
}
function Gu(e) {
  var t = this._id;
  return arguments.length ? this.each(Wu(t, e)) : xe(this.node(), t).ease;
}
function Uu(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    Se(this, e).ease = n;
  };
}
function qu(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(Uu(this._id, e));
}
function Qu(e) {
  typeof e != "function" && (e = Ci(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, s = o[i] = [], l, u = 0; u < a; ++u)
      (l = r[u]) && e.call(l, l.__data__, u, r) && s.push(l);
  return new Be(o, this._parents, this._name, this._id);
}
function ju(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, o = t.length, i = n.length, r = Math.min(o, i), a = new Array(o), s = 0; s < r; ++s)
    for (var l = t[s], u = n[s], c = l.length, f = a[s] = new Array(c), d, w = 0; w < c; ++w)
      (d = l[w] || u[w]) && (f[w] = d);
  for (; s < o; ++s)
    a[s] = t[s];
  return new Be(a, this._parents, this._name, this._id);
}
function Ju(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function ec(e, t, n) {
  var o, i, r = Ju(t) ? so : Se;
  return function() {
    var a = r(this, e), s = a.on;
    s !== o && (i = (o = s).copy()).on(t, n), a.on = i;
  };
}
function tc(e, t) {
  var n = this._id;
  return arguments.length < 2 ? xe(this.node(), n).on.on(e) : this.each(ec(n, e, t));
}
function nc(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function oc() {
  return this.on("end.remove", nc(this._id));
}
function ic(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Qn(e));
  for (var o = this._groups, i = o.length, r = new Array(i), a = 0; a < i; ++a)
    for (var s = o[a], l = s.length, u = r[a] = new Array(l), c, f, d = 0; d < l; ++d)
      (c = s[d]) && (f = e.call(c, c.__data__, d, s)) && ("__data__" in c && (f.__data__ = c.__data__), u[d] = f, dn(u[d], t, n, d, u, xe(c, n)));
  return new Be(r, this._parents, t, n);
}
function rc(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Si(e));
  for (var o = this._groups, i = o.length, r = [], a = [], s = 0; s < i; ++s)
    for (var l = o[s], u = l.length, c, f = 0; f < u; ++f)
      if (c = l[f]) {
        for (var d = e.call(c, c.__data__, f, l), w, g = xe(c, n), h = 0, _ = d.length; h < _; ++h)
          (w = d[h]) && dn(w, t, n, h, d, g);
        r.push(d), a.push(c);
      }
  return new Be(r, a, t, n);
}
var ac = Nt.prototype.constructor;
function sc() {
  return new ac(this._groups, this._parents);
}
function lc(e, t) {
  var n, o, i;
  return function() {
    var r = st(this, e), a = (this.style.removeProperty(e), st(this, e));
    return r === a ? null : r === n && a === o ? i : i = t(n = r, o = a);
  };
}
function ar(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function uc(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = st(this, e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function cc(e, t, n) {
  var o, i, r;
  return function() {
    var a = st(this, e), s = n(this), l = s + "";
    return s == null && (l = s = (this.style.removeProperty(e), st(this, e))), a === l ? null : a === o && l === i ? r : (i = l, r = t(o = a, s));
  };
}
function dc(e, t) {
  var n, o, i, r = "style." + t, a = "end." + r, s;
  return function() {
    var l = Se(this, e), u = l.on, c = l.value[r] == null ? s || (s = ar(t)) : void 0;
    (u !== n || i !== c) && (o = (n = u).copy()).on(a, i = c), l.on = o;
  };
}
function fc(e, t, n) {
  var o = (e += "") == "transform" ? fu : rr;
  return t == null ? this.styleTween(e, lc(e, o)).on("end.style." + e, ar(e)) : typeof t == "function" ? this.styleTween(e, cc(e, o, lo(this, "style." + e, t))).each(dc(this._id, e)) : this.styleTween(e, uc(e, o, t), n).on("end.style." + e, null);
}
function hc(e, t, n) {
  return function(o) {
    this.style.setProperty(e, t.call(this, o), n);
  };
}
function gc(e, t, n) {
  var o, i;
  function r() {
    var a = t.apply(this, arguments);
    return a !== i && (o = (i = a) && hc(e, a, n)), o;
  }
  return r._value = t, r;
}
function vc(e, t, n) {
  var o = "style." + (e += "");
  if (arguments.length < 2)
    return (o = this.tween(o)) && o._value;
  if (t == null)
    return this.tween(o, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(o, gc(e, t, n == null ? "" : n));
}
function pc(e) {
  return function() {
    this.textContent = e;
  };
}
function mc(e) {
  return function() {
    var t = e(this);
    this.textContent = t == null ? "" : t;
  };
}
function yc(e) {
  return this.tween("text", typeof e == "function" ? mc(lo(this, "text", e)) : pc(e == null ? "" : e + ""));
}
function xc(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function wc(e) {
  var t, n;
  function o() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && xc(i)), t;
  }
  return o._value = e, o;
}
function _c(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, wc(e));
}
function bc() {
  for (var e = this._name, t = this._id, n = sr(), o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], s = a.length, l, u = 0; u < s; ++u)
      if (l = a[u]) {
        var c = xe(l, t);
        dn(l, e, n, u, a, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Be(o, this._parents, e, n);
}
function Nc() {
  var e, t, n = this, o = n._id, i = n.size();
  return new Promise(function(r, a) {
    var s = { value: a }, l = { value: function() {
      --i === 0 && r();
    } };
    n.each(function() {
      var u = Se(this, o), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(l)), u.on = t;
    }), i === 0 && r();
  });
}
var Ec = 0;
function Be(e, t, n, o) {
  this._groups = e, this._parents = t, this._name = n, this._id = o;
}
function sr() {
  return ++Ec;
}
var Ce = Nt.prototype;
Be.prototype = {
  constructor: Be,
  select: ic,
  selectAll: rc,
  selectChild: Ce.selectChild,
  selectChildren: Ce.selectChildren,
  filter: Qu,
  merge: ju,
  selection: sc,
  transition: bc,
  call: Ce.call,
  nodes: Ce.nodes,
  node: Ce.node,
  size: Ce.size,
  empty: Ce.empty,
  each: Ce.each,
  on: tc,
  attr: Tu,
  attrTween: Lu,
  style: fc,
  styleTween: vc,
  text: yc,
  textTween: _c,
  remove: oc,
  tween: ku,
  delay: Yu,
  duration: Ku,
  ease: Gu,
  easeVarying: qu,
  end: Nc,
  [Symbol.iterator]: Ce[Symbol.iterator]
};
function Sc(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Cc = {
  time: null,
  delay: 0,
  duration: 250,
  ease: Sc
};
function $c(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function kc(e) {
  var t, n;
  e instanceof Be ? (t = e._id, e = e._name) : (t = sr(), (n = Cc).time = ao(), e = e == null ? null : e + "");
  for (var o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], s = a.length, l, u = 0; u < s; ++u)
      (l = a[u]) && dn(l, e, t, u, a, n || $c(l, t));
  return new Be(o, this._parents, e, t);
}
Nt.prototype.interrupt = Su;
Nt.prototype.transition = kc;
const Bt = (e) => () => e;
function Mc(e, {
  sourceEvent: t,
  target: n,
  transform: o,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function ke(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
ke.prototype = {
  constructor: ke,
  scale: function(e) {
    return e === 1 ? this : new ke(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new ke(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var fn = new ke(1, 0, 0);
ke.prototype;
function yn(e) {
  e.stopImmediatePropagation();
}
function dt(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Oc(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function zc() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function qo() {
  return this.__zoom || fn;
}
function Pc(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Ac() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Bc(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], r = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > o ? (o + i) / 2 : Math.min(0, o) || Math.max(0, i),
    a > r ? (r + a) / 2 : Math.min(0, r) || Math.max(0, a)
  );
}
function Tc() {
  var e = Oc, t = zc, n = Bc, o = Pc, i = Ac, r = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, l = mu, u = sn("start", "zoom", "end"), c, f, d, w = 500, g = 150, h = 0, _ = 10;
  function v(m) {
    m.property("__zoom", qo).on("wheel.zoom", R, { passive: !1 }).on("mousedown.zoom", D).on("dblclick.zoom", I).filter(i).on("touchstart.zoom", G).on("touchmove.zoom", Z).on("touchend.zoom touchcancel.zoom", j).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  v.transform = function(m, A, C, B) {
    var F = m.selection ? m.selection() : m;
    F.property("__zoom", qo), m !== F ? M(m, A, C, B) : F.interrupt().each(function() {
      p(this, arguments).event(B).start().zoom(null, typeof A == "function" ? A.apply(this, arguments) : A).end();
    });
  }, v.scaleBy = function(m, A, C, B) {
    v.scaleTo(m, function() {
      var F = this.__zoom.k, P = typeof A == "function" ? A.apply(this, arguments) : A;
      return F * P;
    }, C, B);
  }, v.scaleTo = function(m, A, C, B) {
    v.transform(m, function() {
      var F = t.apply(this, arguments), P = this.__zoom, k = C == null ? y(F) : typeof C == "function" ? C.apply(this, arguments) : C, L = P.invert(k), K = typeof A == "function" ? A.apply(this, arguments) : A;
      return n(S(b(P, K), k, L), F, a);
    }, C, B);
  }, v.translateBy = function(m, A, C, B) {
    v.transform(m, function() {
      return n(this.__zoom.translate(
        typeof A == "function" ? A.apply(this, arguments) : A,
        typeof C == "function" ? C.apply(this, arguments) : C
      ), t.apply(this, arguments), a);
    }, null, B);
  }, v.translateTo = function(m, A, C, B, F) {
    v.transform(m, function() {
      var P = t.apply(this, arguments), k = this.__zoom, L = B == null ? y(P) : typeof B == "function" ? B.apply(this, arguments) : B;
      return n(fn.translate(L[0], L[1]).scale(k.k).translate(
        typeof A == "function" ? -A.apply(this, arguments) : -A,
        typeof C == "function" ? -C.apply(this, arguments) : -C
      ), P, a);
    }, B, F);
  };
  function b(m, A) {
    return A = Math.max(r[0], Math.min(r[1], A)), A === m.k ? m : new ke(A, m.x, m.y);
  }
  function S(m, A, C) {
    var B = A[0] - C[0] * m.k, F = A[1] - C[1] * m.k;
    return B === m.x && F === m.y ? m : new ke(m.k, B, F);
  }
  function y(m) {
    return [(+m[0][0] + +m[1][0]) / 2, (+m[0][1] + +m[1][1]) / 2];
  }
  function M(m, A, C, B) {
    m.on("start.zoom", function() {
      p(this, arguments).event(B).start();
    }).on("interrupt.zoom end.zoom", function() {
      p(this, arguments).event(B).end();
    }).tween("zoom", function() {
      var F = this, P = arguments, k = p(F, P).event(B), L = t.apply(F, P), K = C == null ? y(L) : typeof C == "function" ? C.apply(F, P) : C, oe = Math.max(L[1][0] - L[0][0], L[1][1] - L[0][1]), $ = F.__zoom, Y = typeof A == "function" ? A.apply(F, P) : A, U = l($.invert(K).concat(oe / $.k), Y.invert(K).concat(oe / Y.k));
      return function(x) {
        if (x === 1)
          x = Y;
        else {
          var E = U(x), H = oe / E[2];
          x = new ke(H, K[0] - E[0] * H, K[1] - E[1] * H);
        }
        k.zoom(null, x);
      };
    });
  }
  function p(m, A, C) {
    return !C && m.__zooming || new O(m, A);
  }
  function O(m, A) {
    this.that = m, this.args = A, this.active = 0, this.sourceEvent = null, this.extent = t.apply(m, A), this.taps = 0;
  }
  O.prototype = {
    event: function(m) {
      return m && (this.sourceEvent = m), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(m, A) {
      return this.mouse && m !== "mouse" && (this.mouse[1] = A.invert(this.mouse[0])), this.touch0 && m !== "touch" && (this.touch0[1] = A.invert(this.touch0[0])), this.touch1 && m !== "touch" && (this.touch1[1] = A.invert(this.touch1[0])), this.that.__zoom = A, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(m) {
      var A = me(this.that).datum();
      u.call(
        m,
        this.that,
        new Mc(m, {
          sourceEvent: this.sourceEvent,
          target: v,
          type: m,
          transform: this.that.__zoom,
          dispatch: u
        }),
        A
      );
    }
  };
  function R(m, ...A) {
    if (!e.apply(this, arguments))
      return;
    var C = p(this, A).event(m), B = this.__zoom, F = Math.max(r[0], Math.min(r[1], B.k * Math.pow(2, o.apply(this, arguments)))), P = we(m);
    if (C.wheel)
      (C.mouse[0][0] !== P[0] || C.mouse[0][1] !== P[1]) && (C.mouse[1] = B.invert(C.mouse[0] = P)), clearTimeout(C.wheel);
    else {
      if (B.k === F)
        return;
      C.mouse = [P, B.invert(P)], Ht(this), C.start();
    }
    dt(m), C.wheel = setTimeout(k, g), C.zoom("mouse", n(S(b(B, F), C.mouse[0], C.mouse[1]), C.extent, a));
    function k() {
      C.wheel = null, C.end();
    }
  }
  function D(m, ...A) {
    if (d || !e.apply(this, arguments))
      return;
    var C = m.currentTarget, B = p(this, A, !0).event(m), F = me(m.view).on("mousemove.zoom", K, !0).on("mouseup.zoom", oe, !0), P = we(m, C), k = m.clientX, L = m.clientY;
    Ii(m.view), yn(m), B.mouse = [P, this.__zoom.invert(P)], Ht(this), B.start();
    function K($) {
      if (dt($), !B.moved) {
        var Y = $.clientX - k, U = $.clientY - L;
        B.moved = Y * Y + U * U > h;
      }
      B.event($).zoom("mouse", n(S(B.that.__zoom, B.mouse[0] = we($, C), B.mouse[1]), B.extent, a));
    }
    function oe($) {
      F.on("mousemove.zoom mouseup.zoom", null), Di($.view, B.moved), dt($), B.event($).end();
    }
  }
  function I(m, ...A) {
    if (!!e.apply(this, arguments)) {
      var C = this.__zoom, B = we(m.changedTouches ? m.changedTouches[0] : m, this), F = C.invert(B), P = C.k * (m.shiftKey ? 0.5 : 2), k = n(S(b(C, P), B, F), t.apply(this, A), a);
      dt(m), s > 0 ? me(this).transition().duration(s).call(M, k, B, m) : me(this).call(v.transform, k, B, m);
    }
  }
  function G(m, ...A) {
    if (!!e.apply(this, arguments)) {
      var C = m.touches, B = C.length, F = p(this, A, m.changedTouches.length === B).event(m), P, k, L, K;
      for (yn(m), k = 0; k < B; ++k)
        L = C[k], K = we(L, this), K = [K, this.__zoom.invert(K), L.identifier], F.touch0 ? !F.touch1 && F.touch0[2] !== K[2] && (F.touch1 = K, F.taps = 0) : (F.touch0 = K, P = !0, F.taps = 1 + !!c);
      c && (c = clearTimeout(c)), P && (F.taps < 2 && (f = K[0], c = setTimeout(function() {
        c = null;
      }, w)), Ht(this), F.start());
    }
  }
  function Z(m, ...A) {
    if (!!this.__zooming) {
      var C = p(this, A).event(m), B = m.changedTouches, F = B.length, P, k, L, K;
      for (dt(m), P = 0; P < F; ++P)
        k = B[P], L = we(k, this), C.touch0 && C.touch0[2] === k.identifier ? C.touch0[0] = L : C.touch1 && C.touch1[2] === k.identifier && (C.touch1[0] = L);
      if (k = C.that.__zoom, C.touch1) {
        var oe = C.touch0[0], $ = C.touch0[1], Y = C.touch1[0], U = C.touch1[1], x = (x = Y[0] - oe[0]) * x + (x = Y[1] - oe[1]) * x, E = (E = U[0] - $[0]) * E + (E = U[1] - $[1]) * E;
        k = b(k, Math.sqrt(x / E)), L = [(oe[0] + Y[0]) / 2, (oe[1] + Y[1]) / 2], K = [($[0] + U[0]) / 2, ($[1] + U[1]) / 2];
      } else if (C.touch0)
        L = C.touch0[0], K = C.touch0[1];
      else
        return;
      C.zoom("touch", n(S(k, L, K), C.extent, a));
    }
  }
  function j(m, ...A) {
    if (!!this.__zooming) {
      var C = p(this, A).event(m), B = m.changedTouches, F = B.length, P, k;
      for (yn(m), d && clearTimeout(d), d = setTimeout(function() {
        d = null;
      }, w), P = 0; P < F; ++P)
        k = B[P], C.touch0 && C.touch0[2] === k.identifier ? delete C.touch0 : C.touch1 && C.touch1[2] === k.identifier && delete C.touch1;
      if (C.touch1 && !C.touch0 && (C.touch0 = C.touch1, delete C.touch1), C.touch0)
        C.touch0[1] = this.__zoom.invert(C.touch0[0]);
      else if (C.end(), C.taps === 2 && (k = we(k, this), Math.hypot(f[0] - k[0], f[1] - k[1]) < _)) {
        var L = me(this).on("dblclick.zoom");
        L && L.apply(this, arguments);
      }
    }
  }
  return v.wheelDelta = function(m) {
    return arguments.length ? (o = typeof m == "function" ? m : Bt(+m), v) : o;
  }, v.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Bt(!!m), v) : e;
  }, v.touchable = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : Bt(!!m), v) : i;
  }, v.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : Bt([[+m[0][0], +m[0][1]], [+m[1][0], +m[1][1]]]), v) : t;
  }, v.scaleExtent = function(m) {
    return arguments.length ? (r[0] = +m[0], r[1] = +m[1], v) : [r[0], r[1]];
  }, v.translateExtent = function(m) {
    return arguments.length ? (a[0][0] = +m[0][0], a[1][0] = +m[1][0], a[0][1] = +m[0][1], a[1][1] = +m[1][1], v) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, v.constrain = function(m) {
    return arguments.length ? (n = m, v) : n;
  }, v.duration = function(m) {
    return arguments.length ? (s = +m, v) : s;
  }, v.interpolate = function(m) {
    return arguments.length ? (l = m, v) : l;
  }, v.on = function() {
    var m = u.on.apply(u, arguments);
    return m === u ? v : m;
  }, v.clickDistance = function(m) {
    return arguments.length ? (h = (m = +m) * m, v) : Math.sqrt(h);
  }, v.tapDistance = function(m) {
    return arguments.length ? (_ = +m, v) : _;
  }, v;
}
const xn = 0.1, wn = (e, t = 0) => e.transition().duration(t), Ue = async (e, t) => {
  const n = bt();
  return "screen" in n && (await Ke(e).toMatch(({ height: o, width: i }) => !isNaN(i) && i > 0 && !isNaN(o) && o > 0), t.length > 0 && await Ke(t).toMatch(
    (o) => !!o.filter(({ dimensions: { width: i, height: r } }) => !isNaN(i) && i > 0 && !isNaN(r) && r > 0).length
  )), !0;
}, Ic = (e) => {
  const t = ue({ id: e }), n = N(t, "onPaneReady"), o = N(t, "nodes"), i = N(t, "d3Zoom"), r = N(t, "d3Selection"), a = N(t, "dimensions"), s = N(t, "translateExtent"), l = N(t, "minZoom"), u = N(t, "maxZoom"), c = N(t, "viewport"), f = N(t, "snapToGrid"), d = N(t, "snapGrid"), w = N(t, "getNodes");
  let g = ie(!1);
  n.value(() => g.value = !0);
  const h = async (y, M) => {
    g.value || await Ue(a.value, w.value), r.value && i.value && i.value.scaleTo(wn(r.value, M == null ? void 0 : M.duration), y);
  }, _ = async (y, M) => {
    g.value || await Ue(a.value, w.value), r.value && i.value && i.value.scaleBy(wn(r.value, M), y);
  }, v = async (y) => {
    await _(1.2, y == null ? void 0 : y.duration);
  }, b = async (y) => {
    await _(1 / 1.2, y == null ? void 0 : y.duration);
  }, S = (y, M, p, O) => {
    const { x: R, y: D } = ci({ x: -y, y: -M }, s.value), I = fn.translate(-R, -D).scale(p);
    r.value && i.value && i.value.transform(wn(r.value, O), I);
  };
  return {
    zoomIn: v,
    zoomOut: b,
    zoomTo: h,
    setTransform: async (y, M) => {
      g.value || await Ue(a.value, w.value), S(y.x, y.y, y.zoom, M == null ? void 0 : M.duration);
    },
    getTransform: () => ({
      x: c.value.x,
      y: c.value.y,
      zoom: c.value.zoom
    }),
    fitView: async (y = {
      padding: xn,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      var I, G, Z;
      if (g.value || await Ue(a.value, w.value), !w.value.length)
        return;
      let M = [];
      y.nodes && (M = o.value.filter((j) => {
        var m;
        return (m = y.nodes) == null ? void 0 : m.includes(j.id);
      })), (!M || !M.length) && (M = y.includeHiddenNodes ? M : w.value);
      const p = vi(M), { x: O, y: R, zoom: D } = _o(
        p,
        a.value.width,
        a.value.height,
        (I = y.minZoom) != null ? I : l.value,
        (G = y.maxZoom) != null ? G : u.value,
        (Z = y.padding) != null ? Z : xn,
        y.offset
      );
      S(O, R, D, y == null ? void 0 : y.duration);
    },
    setCenter: async (y, M, p) => {
      g.value || await Ue(a.value, w.value);
      const O = typeof (p == null ? void 0 : p.zoom) < "u" ? p.zoom : u.value, R = a.value.width / 2 - y * O, D = a.value.height / 2 - M * O;
      S(R, D, O, p == null ? void 0 : p.duration);
    },
    fitBounds: async (y, M = { padding: xn }) => {
      g.value || await Ue(a.value, w.value);
      const { x: p, y: O, zoom: R } = _o(y, a.value.width, a.value.height, l.value, u.value, M.padding);
      S(p, O, R, M == null ? void 0 : M.duration);
    },
    project: (y) => fi(y, c.value, f.value, d.value)
  };
};
function Qo(e, t) {
  var n, o;
  if (t) {
    const i = e.position.x + e.dimensions.width - t.dimensions.width, r = e.position.y + e.dimensions.height - t.dimensions.height;
    if (i > 0 || r > 0 || e.position.x < 0 || e.position.y < 0) {
      if (t.style ? Pe(t.style) && (t.style = { ...t.style(t) }) : t.style = {}, t.style.width = (n = t.style.width) != null ? n : t.dimensions.width, t.style.height = (o = t.style.height) != null ? o : t.dimensions.height, i > 0)
        if (Ie(t.style.width)) {
          const a = Number(t.style.width.replace("px", ""));
          t.style.width = `${a + i}px`;
        } else
          t.style.width += i;
      if (r > 0)
        if (Ie(t.style.height)) {
          const a = Number(t.style.height.replace("px", ""));
          t.style.height = `${a + r}px`;
        } else
          t.style.height += r;
      if (e.position.x < 0) {
        const a = Math.abs(e.position.x);
        if (t.position.x = t.position.x - a, Ie(t.style.width)) {
          const s = Number(t.style.width.replace("px", ""));
          t.style.width = `${s + a}px`;
        } else
          t.style.width += a;
        e.position.x = 0;
      }
      if (e.position.y < 0) {
        const a = Math.abs(e.position.y);
        if (t.position.y = t.position.y - a, Ie(t.style.height)) {
          const s = Number(t.style.height.replace("px", ""));
          t.style.height = `${s + a}px`;
        } else
          t.style.height += a;
        e.position.y = 0;
      }
      t.dimensions.width = Number(t.style.width.toString().replace("px", "")), t.dimensions.height = Number(t.style.height.toString().replace("px", ""));
    }
  }
}
const en = (e, t) => {
  e.filter((i) => i.type === "add" || i.type === "remove").forEach((i) => {
    switch (i.type) {
      case "add":
        t.push(i.item);
        break;
      case "remove":
        t.splice(
          t.findIndex((r) => r.id === i.id),
          1
        );
        break;
    }
  });
  const o = t.map((i) => i.id);
  return t.forEach((i) => {
    var a, s;
    const r = e.filter((l) => l.id === i.id);
    for (const l of r)
      switch (l.type) {
        case "select":
          i.selected = l.selected;
          break;
        case "position":
          if (De(i) && (typeof l.position < "u" && (i.position = l.position), typeof l.dragging < "u" && (i.dragging = l.dragging), i.expandParent && i.parentNode)) {
            const u = t[o.indexOf(i.parentNode)];
            u && De(u) && Qo(i, u);
          }
          break;
        case "dimensions":
          if (De(i) && (typeof l.dimensions < "u" && (i.dimensions = l.dimensions), typeof l.updateStyle < "u" && (i.style = {
            ...i.style || {},
            width: `${(a = l.dimensions) == null ? void 0 : a.width}px`,
            height: `${(s = l.dimensions) == null ? void 0 : s.height}px`
          }), typeof l.resizing == "boolean" && (i.resizing = l.resizing), i.expandParent && i.parentNode)) {
            const u = t[o.indexOf(i.parentNode)];
            u && De(u) && Qo(i, u);
          }
          break;
      }
  }), t;
}, xd = (e, t) => en(e, t), wd = (e, t) => en(e, t), $e = (e, t) => ({
  id: e,
  type: "select",
  selected: t
}), jo = (e) => ({
  item: e,
  type: "add"
}), _n = (e) => ({
  id: e,
  type: "remove"
}), bn = (e, t) => e.reduce(
  (n, o) => {
    const i = t.includes(o.id), r = De(o) ? "changedNodes" : "changedEdges";
    return !o.selected && i ? n[r].push($e(o.id, !0)) : o.selected && !i && n[r].push($e(o.id, !1)), n;
  },
  { changedNodes: [], changedEdges: [] }
);
function Dc(e, t) {
  const n = (x) => {
    e.hooks.updateNodeInternals.trigger(x);
  }, o = ie();
  e.hooks.paneReady.on(({ id: x }) => {
    o.value = Ic(x);
  });
  const i = async () => new Promise((x) => {
    o.value ? x(o.value) : Ke(o).not.toBeUndefined().then(() => x(o.value));
  }), r = ne(() => e.nodes.map((x) => x.id)), a = ne(() => e.edges.map((x) => x.id)), s = (x) => e.nodes && !r.value.length ? e.nodes.find((E) => E.id === x) : e.nodes[r.value.indexOf(x)], l = (x) => e.edges && !a.value.length ? e.edges.find((E) => E.id === x) : e.edges[a.value.indexOf(x)], u = (x, E, H) => {
    const V = [];
    x.forEach((Q) => {
      var ee, T, J, se;
      const W = {
        id: Q.id,
        type: "position",
        dragging: H,
        from: Q.from
      };
      if (E && (W.position = Q.position, Q.parentNode)) {
        const de = s(Q.parentNode);
        W.position = {
          x: W.position.x - ((T = (ee = de == null ? void 0 : de.computedPosition) == null ? void 0 : ee.x) != null ? T : 0),
          y: W.position.y - ((se = (J = de == null ? void 0 : de.computedPosition) == null ? void 0 : J.y) != null ? se : 0)
        };
      }
      V.push(W);
    }), V != null && V.length && e.hooks.nodesChange.trigger(V);
  }, c = (x) => {
    var Q;
    if (!e.vueFlowRef)
      return;
    const E = e.vueFlowRef.querySelector(".vue-flow__transformationpane");
    if (!E)
      return;
    let H;
    if ((Q = e.__experimentalFeatures) != null && Q.nestedFlow) {
      let W = [E], ee = E, T;
      for (; !T && ee; )
        ee = ee.parentElement, T = ee == null ? void 0 : ee.classList.contains("vue-flow__transformationpane"), T && (W = [ee, ...W]);
      W.forEach((J) => {
        const se = window.getComputedStyle(J), { m22: de } = new window.DOMMatrixReadOnly(se.transform);
        H ? H *= de : H = de;
      });
    } else {
      const W = window.getComputedStyle(E), { m22: ee } = new window.DOMMatrixReadOnly(W.transform);
      H = ee;
    }
    const V = x.reduce((W, ee) => {
      const T = t.getNode.value(ee.id);
      if (T) {
        const J = nn(ee.nodeElement);
        !!(J.width && J.height && (T.width !== J.width || T.height !== J.height || ee.forceUpdate)) && (T.handleBounds.source = So(".source", ee.nodeElement, H), T.handleBounds.target = So(".target", ee.nodeElement, H), T.initialized || (T.initialized = !0), W.push({
          id: T.id,
          type: "dimensions",
          dimensions: J
        }));
      }
      return W;
    }, []);
    V.length && e.hooks.nodesChange.trigger(V);
  }, f = (x, E) => {
    const H = x.map((W) => W.id);
    let V, Q = [];
    if (e.multiSelectionActive)
      V = H.map((W) => $e(W, E));
    else {
      const W = bn([...e.nodes, ...e.edges], H);
      V = W.changedNodes, Q = W.changedEdges;
    }
    V.length && e.hooks.nodesChange.trigger(V), Q.length && e.hooks.edgesChange.trigger(Q);
  }, d = (x, E) => {
    const H = x.map((W) => W.id);
    let V = [], Q;
    if (e.multiSelectionActive)
      Q = H.map((W) => $e(W, E));
    else {
      const W = bn([...e.nodes, ...e.edges], H);
      V = W.changedNodes, Q = W.changedEdges;
    }
    V.length && e.hooks.nodesChange.trigger(V), Q.length && e.hooks.edgesChange.trigger(Q);
  }, w = (x, E) => {
    const H = x.filter(De), V = x.filter(Yn), Q = H.map((J) => J.id), W = V.map((J) => J.id);
    let { changedNodes: ee, changedEdges: T } = bn([...e.nodes, ...e.edges], [...Q, ...W]);
    e.multiSelectionActive && (ee = Q.map((J) => $e(J, E))), e.multiSelectionActive && (T = W.map((J) => $e(J, E))), ee.length && e.hooks.nodesChange.trigger(ee), T.length && e.hooks.edgesChange.trigger(T);
  }, g = (x) => {
    f(x, !0);
  }, h = (x) => {
    d(x, !0);
  }, _ = (x) => {
    w(x, !0);
  }, v = (x) => {
    if (!x.length)
      return f(x, !1);
    const H = x.map((V) => V.id).map((V) => $e(V, !1));
    H.length && e.hooks.nodesChange.trigger(H);
  }, b = (x) => {
    if (!x.length)
      return d(x, !1);
    const H = x.map((V) => V.id).map((V) => $e(V, !1));
    H.length && e.hooks.edgesChange.trigger(H);
  }, S = (x) => {
    if (!x || !x.length)
      return w([], !1);
    const { changedNodes: E, changedEdges: H } = x.reduce(
      (V, Q) => {
        const W = $e(Q.id, !1);
        return De(Q) ? V.changedNodes.push(W) : V.changedEdges.push(W), V;
      },
      { changedNodes: [], changedEdges: [] }
    );
    E.length && e.hooks.nodesChange.trigger(E), H.length && e.hooks.edgesChange.trigger(H);
  }, y = (x) => {
    var E;
    (E = e.d3Zoom) == null || E.scaleExtent([x, e.maxZoom]), e.minZoom = x;
  }, M = (x) => {
    var E;
    (E = e.d3Zoom) == null || E.scaleExtent([e.minZoom, x]), e.maxZoom = x;
  }, p = (x) => {
    var E;
    (E = e.d3Zoom) == null || E.translateExtent(x), e.translateExtent = x;
  }, O = async (x) => {
    if (e.nodeExtent = x, o.value) {
      const E = t.getNodes.value.map((H) => H.id);
      n(E);
    }
  }, R = (x) => {
    e.nodesDraggable = x, e.nodesConnectable = x, e.elementsSelectable = x;
  }, D = (x, E) => {
    if (!e.initialized && !x.length)
      return;
    e.nodes || (e.nodes = []);
    const H = x instanceof Function ? x(e.nodes) : x;
    e.nodes = bo(H, t.getNode.value, e.nodes, E != null ? E : e.nodeExtent);
  }, I = (x) => {
    if (!e.initialized && !x.length)
      return;
    const E = x instanceof Function ? x(e.edges) : x;
    e.edges = E.reduce((H, V) => {
      const Q = t.getNode.value(V.source), W = t.getNode.value(V.target), ee = !Q || typeof Q > "u", T = !W || typeof W > "u";
      if (ee && he(`Couldn't create edge for source id: ${V.source}; edge id: ${V.id}`), T && he(`Couldn't create edge for target id: ${V.target}; edge id: ${V.id}`), ee || T)
        return H;
      const J = t.getEdge.value(V.id);
      return H.push({
        ...Zn(V, Object.assign({}, J, e.defaultEdgeOptions)),
        sourceNode: Q,
        targetNode: W
      }), H;
    }, []);
  }, G = (x, E) => {
    if (!e.initialized && !x.length || !x)
      return;
    const H = x instanceof Function ? x([...e.nodes, ...e.edges]) : x;
    D(H.filter(Xn), E), I(H.filter(Ae));
  }, Z = (x, E) => {
    const H = x instanceof Function ? x(e.nodes) : x, Q = bo(H, t.getNode.value, e.nodes, E != null ? E : e.nodeExtent).map(jo);
    Q.length && e.hooks.nodesChange.trigger(Q);
  }, j = (x) => {
    const H = (x instanceof Function ? x(e.edges) : x).reduce((V, Q) => {
      const W = oa(
        {
          ...Q,
          ...e.defaultEdgeOptions
        },
        e.edges
      );
      if (W) {
        const ee = t.getNode.value(W.source), T = t.getNode.value(W.target), J = !ee || typeof ee > "u", se = !T || typeof T > "u";
        if (J && he(`Couldn't create edge for source id: ${W.source}; edge id: ${W.id}`), se && he(`Couldn't create edge for target id: ${W.target}; edge id: ${W.id}`), se || J)
          return V;
        V.push(
          jo({
            ...W,
            sourceNode: ee,
            targetNode: T
          })
        );
      }
      return V;
    }, []);
    H.length && e.hooks.edgesChange.trigger(H);
  }, m = (x, E = !0) => {
    const H = x instanceof Function ? x(e.nodes) : x, V = [], Q = [];
    H.forEach((W) => {
      if (V.push(_n(typeof W == "string" ? W : W.id)), E) {
        const ee = rn([typeof W == "string" ? { id: W } : W], e.edges);
        Q.push(...ee.map((T) => _n(T.id)));
      }
    }), V.length && e.hooks.nodesChange.trigger(V), Q.length && e.hooks.edgesChange.trigger(Q);
  }, A = (x) => {
    const E = x instanceof Function ? x(e.edges) : x, H = [];
    E.forEach((V) => {
      H.push(_n(typeof V == "string" ? V : V.id));
    }), e.hooks.edgesChange.trigger(H);
  }, C = (x, E) => ia(x, E, e.edges), B = (x) => en(x, e.nodes), F = (x) => en(x, e.edges), P = (x, E, H, V = !1) => {
    V ? e.connectionClickStartHandle = x : e.connectionStartHandle = x, E && (e.connectionPosition = E), e.hooks.connectStart.trigger({
      event: H,
      nodeId: x.nodeId,
      handleId: x.handleId,
      handleType: x.type
    });
  }, k = (x) => {
    e.connectionPosition = x;
  }, L = (x, E) => {
    e.connectionPosition = { x: NaN, y: NaN }, E ? e.connectionClickStartHandle = null : e.connectionStartHandle = null, e.hooks.connectEnd.trigger(x);
  }, K = (x) => {
    const E = ea(x), H = E ? null : s(x.id);
    return !E && !H ? [null, null, E] : [E ? x : wo(H), H, E];
  }, oe = (x, E = !0, H) => {
    const [V, Q, W] = K(x);
    return V ? (H || e.nodes).filter((ee) => {
      if (!W && (ee.id === Q.id || !ee.computedPosition))
        return !1;
      const T = wo(ee), J = $n(T, V);
      return E && J > 0 || J >= Number(x.width) * Number(x.height);
    }) : [];
  }, $ = (x, E, H = !0) => {
    const [V] = K(x);
    if (!V)
      return !1;
    const Q = $n(V, E);
    return H && Q > 0 || Q >= Number(x.width) * Number(x.height);
  }, Y = (x) => {
    var Q, W;
    const E = x instanceof Function ? x(e) : x, H = [
      "modelValue",
      "nodes",
      "edges",
      "maxZoom",
      "minZoom",
      "translateExtent",
      "nodeExtent",
      "hooks"
    ];
    typeof E.modelValue < "u" && G(E.modelValue, (Q = E.nodeExtent) != null ? Q : e.nodeExtent), typeof E.nodes < "u" && D(E.nodes, (W = E.nodeExtent) != null ? W : e.nodeExtent), typeof E.edges < "u" && I(E.edges);
    const V = () => {
      typeof E.maxZoom < "u" && M(E.maxZoom), typeof E.minZoom < "u" && y(E.minZoom), typeof E.translateExtent < "u" && p(E.translateExtent), typeof E.nodeExtent < "u" && O(E.nodeExtent);
    };
    Object.keys(E).forEach((ee) => {
      const T = E[ee];
      !H.includes(ee) && fe(T) && (e[ee] = T);
    }), e.d3Zoom ? V() : Ke(() => e.d3Zoom).not.toBeUndefined().then(V), e.initialized || (e.initialized = !0);
  };
  return {
    updateNodePositions: u,
    updateNodeDimensions: c,
    setElements: G,
    setNodes: D,
    setEdges: I,
    addNodes: Z,
    addEdges: j,
    removeNodes: m,
    removeEdges: A,
    findNode: s,
    findEdge: l,
    updateEdge: C,
    applyEdgeChanges: F,
    applyNodeChanges: B,
    addSelectedElements: _,
    addSelectedNodes: g,
    addSelectedEdges: h,
    setMinZoom: y,
    setMaxZoom: M,
    setTranslateExtent: p,
    setNodeExtent: O,
    removeSelectedElements: S,
    removeSelectedNodes: v,
    removeSelectedEdges: b,
    startConnection: P,
    updateConnection: k,
    endConnection: L,
    setInteractive: R,
    setState: Y,
    getIntersectingNodes: oe,
    isNodeIntersecting: $,
    fitView: async (x = { padding: 0.1 }) => {
      const { fitView: E } = await i();
      E(x);
    },
    zoomIn: async (x) => {
      const { zoomIn: E } = await i();
      E(x);
    },
    zoomOut: async (x) => {
      const { zoomOut: E } = await i();
      E(x);
    },
    zoomTo: async (x, E) => {
      const { zoomTo: H } = await i();
      H(x, E);
    },
    setTransform: async (x, E) => {
      const { setTransform: H } = await i();
      H(x, E);
    },
    getTransform: () => ({
      x: e.viewport.x,
      y: e.viewport.y,
      zoom: e.viewport.zoom
    }),
    setCenter: async (x, E, H) => {
      const { setCenter: V } = await i();
      V(x, E, H);
    },
    fitBounds: async (x, E) => {
      const { fitBounds: H } = await i();
      H(x, E);
    },
    project: (x) => fi(x, e.viewport, e.snapToGrid, e.snapGrid),
    toObject: () => JSON.parse(
      JSON.stringify({
        nodes: e.nodes,
        edges: e.edges,
        position: [e.viewport.x, e.viewport.y],
        zoom: e.viewport.zoom
      })
    ),
    updateNodeInternals: n,
    $reset: () => {
      Y(Gi());
    },
    $destroy: () => {
    }
  };
}
const Qe = class {
  constructor() {
    $t(this, "currentId", 0);
    $t(this, "flows", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    return Qe.instance || (Qe.instance = new Qe()), Qe.instance;
  }
  set(t, n) {
    return this.flows.set(t, n);
  }
  get(t) {
    return this.flows.get(t);
  }
  remove(t) {
    return this.flows.delete(t);
  }
  create(t, n) {
    const o = Gi(n), i = yr(o), r = Zl(i), a = Dc(i, r), s = {};
    Object.entries(i.hooks).forEach(([c, f]) => {
      const d = `on${c.charAt(0).toUpperCase() + c.slice(1)}`;
      s[d] = f.on;
    });
    const l = {};
    Object.entries(i.hooks).forEach(([c, f]) => {
      l[c] = f.trigger;
    }), a.setState(i), n && (n.modelValue && a.setElements(n.modelValue), n.nodes && a.setNodes(n.nodes), n.edges && a.setEdges(n.edges));
    const u = {
      ...s,
      ...r,
      ...a,
      ...xr(i),
      emits: l,
      id: t,
      $destroy: () => {
        this.remove(t);
      }
    };
    return this.set(t, u), u;
  }
  getId() {
    return `vue-flow-${this.currentId++}`;
  }
};
let Lt = Qe;
$t(Lt, "instance");
const ue = (e) => {
  const t = Lt.getInstance(), n = ei(), o = e == null ? void 0 : e.id, i = (n == null ? void 0 : n.vueFlowId) || o;
  let r, a = !1;
  if (n) {
    const s = Re(No, null);
    typeof s < "u" && s !== null && (r = s);
  }
  if (r || i && (r = t.get(i)), !r || r && o && o !== r.id) {
    const s = o != null ? o : t.getId();
    r = t.create(s, e), n && (a = !0);
  } else
    e && r.setState(e);
  if (!r)
    throw new Error("[vueflow]: store instance not found.");
  return n && (ot(No, r), n.vueFlowId = r.id, a && _t(() => {
    t.get(r.id) && r.$destroy(), r = null;
  })), r;
}, Rc = (e, t, n) => {
  const o = Vt();
  return o.run(() => {
    [
      () => {
        o.run(() => {
          let g, h;
          const _ = !!(e.modelValue && e.modelValue.value);
          let v = !!(n.nodes.value.length || n.edges.value.length);
          g = Ge(
            [e.modelValue, () => {
              var b, S;
              return (S = (b = e.modelValue) == null ? void 0 : b.value) == null ? void 0 : S.length;
            }],
            ([b]) => {
              b && Array.isArray(b) && (h == null || h.pause(), n.setElements(b), !h && !v && b.length ? v = !0 : h == null || h.resume());
            },
            { immediate: _ }
          ), h = Ge(
            [n.nodes, n.edges, () => n.edges.value.length, () => n.nodes.value.length],
            ([b, S]) => {
              var y;
              ((y = e.modelValue) == null ? void 0 : y.value) && Array.isArray(e.modelValue.value) && (g == null || g.pause(), e.modelValue.value = [...b, ...S], je(() => {
                g == null || g.resume();
              }));
            },
            { immediate: v }
          ), Tt(() => {
            g == null || g.stop(), h == null || h.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let g, h;
          const _ = !!(e.nodes && e.nodes.value);
          let v = !!n.nodes.value.length;
          g = Ge(
            [e.nodes, () => {
              var b, S;
              return (S = (b = e.nodes) == null ? void 0 : b.value) == null ? void 0 : S.length;
            }],
            ([b]) => {
              b && Array.isArray(b) && (h == null || h.pause(), n.setNodes(b), !h && !v && b.length ? v = !0 : h == null || h.resume());
            },
            { immediate: _ }
          ), h = Ge(
            [n.nodes, () => n.nodes.value.length],
            ([b]) => {
              var S;
              ((S = e.nodes) == null ? void 0 : S.value) && Array.isArray(e.nodes.value) && (g == null || g.pause(), e.nodes.value = [...b], je(() => {
                g == null || g.resume();
              }));
            },
            { immediate: v }
          ), Tt(() => {
            g == null || g.stop(), h == null || h.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let g, h;
          const _ = !!(e.edges && e.edges.value);
          let v = !!n.edges.value.length;
          g = Ge(
            [e.edges, () => {
              var b, S;
              return (S = (b = e.edges) == null ? void 0 : b.value) == null ? void 0 : S.length;
            }],
            ([b]) => {
              b && Array.isArray(b) && (h == null || h.pause(), n.setEdges(b), !h && !v && b.length ? v = !0 : h == null || h.resume());
            },
            { immediate: _ }
          ), h = Ge(
            [n.edges, () => n.edges.value.length],
            ([b]) => {
              var S;
              ((S = e.edges) == null ? void 0 : S.value) && Array.isArray(e.edges.value) && (g == null || g.pause(), e.edges.value = [...b], je(() => {
                g == null || g.resume();
              }));
            },
            { immediate: v }
          ), Tt(() => {
            g == null || g.stop(), h == null || h.stop();
          });
        });
      },
      () => {
        o.run(() => {
          le(
            () => t.minZoom,
            () => {
              t.minZoom && fe(t.minZoom) && n.setMinZoom(t.minZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          le(
            () => t.maxZoom,
            () => {
              t.maxZoom && fe(t.maxZoom) && n.setMaxZoom(t.maxZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          le(
            () => t.translateExtent,
            () => {
              t.translateExtent && fe(t.translateExtent) && n.setTranslateExtent(t.translateExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          le(
            () => t.nodeExtent,
            () => {
              t.nodeExtent && fe(t.nodeExtent) && n.setNodeExtent(t.nodeExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          le(
            () => t.applyDefault,
            () => {
              fe(t.applyDefault) && (n.applyDefault.value = t.applyDefault);
            }
          ), le(
            n.applyDefault,
            (g, h, _) => {
              n.applyDefault.value ? (n.onNodesChange(n.applyNodeChanges), n.onEdgesChange(n.applyEdgeChanges)) : (n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges)), _(() => {
                n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        o.run(() => {
          const g = async (h) => {
            let _ = h;
            Pe(t.autoConnect) && (_ = await t.autoConnect(h)), _ !== !1 && n.addEdges([_]);
          };
          le(
            () => t.autoConnect,
            () => {
              fe(t.autoConnect) && (n.autoConnect.value = t.autoConnect);
            }
          ), le(
            n.autoConnect,
            (h, _, v) => {
              h ? n.onConnect(g) : n.hooks.value.connect.off(g), v(() => {
                n.hooks.value.connect.off(g);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        const g = [
          "id",
          "modelValue",
          "translateExtent",
          "nodeExtent",
          "edges",
          "nodes",
          "maxZoom",
          "minZoom",
          "applyDefault",
          "autoConnect"
        ];
        Object.keys(t).forEach((h) => {
          if (!g.includes(h)) {
            const _ = N(t, h), v = n[h];
            o.run(() => {
              le(
                _,
                (b) => {
                  fe(b) && (v.value = b);
                },
                { flush: "pre" }
              );
            });
          }
        });
      }
    ].forEach((g) => g());
  }), () => o.stop();
};
function Jo(e, t) {
  return {
    x: e.clientX - t.left,
    y: e.clientY - t.top
  };
}
const Hc = {
  name: "Pane"
}, Lc = /* @__PURE__ */ ce({
  ...Hc,
  props: {
    isSelecting: { type: Boolean }
  },
  setup(e) {
    const {
      id: t,
      vueFlowRef: n,
      getNodes: o,
      getEdges: i,
      viewport: r,
      emits: a,
      userSelectionActive: s,
      removeSelectedElements: l,
      panOnDrag: u,
      userSelectionRect: c,
      elementsSelectable: f,
      nodesSelectionActive: d,
      addSelectedElements: w,
      getSelectedEdges: g,
      removeNodes: h,
      removeEdges: _,
      selectionMode: v,
      deleteKeyCode: b,
      multiSelectionKeyCode: S,
      multiSelectionActive: y
    } = ue(), M = ie(null), p = ie(0), O = ie(0), R = ie(), D = ne(() => f.value && (e.isSelecting || s.value));
    vt(b, (P) => {
      if (!P)
        return;
      const k = o.value.reduce((L, K) => ((!K.selected && K.parentNode && L.find((oe) => oe.id === K.parentNode) || K.selected) && L.push(K), L), []);
      (k || g.value) && (g.value.length > 0 && _(g.value), k.length > 0 && h(k), d.value = !1, l());
    }), vt(S, (P) => {
      y.value = P;
    });
    function I() {
      s.value = !1, c.value = null, p.value = 0, O.value = 0;
    }
    function G(P) {
      P.target !== M.value || D.value || (a.paneClick(P), l(), d.value = !1);
    }
    function Z(P) {
      var k;
      if (P.target === M.value) {
        if (Array.isArray(u.value) && ((k = u.value) == null ? void 0 : k.includes(2))) {
          P.preventDefault();
          return;
        }
        a.paneContextMenu(P);
      }
    }
    function j(P) {
      P.target === M.value && a.paneScroll(P);
    }
    function m(P) {
      if (R.value = n.value.getBoundingClientRect(), !D.value || !f || !e.isSelecting || P.button !== 0 || P.target !== M.value || !R.value)
        return;
      const { x: k, y: L } = Jo(P, R.value);
      l(), c.value = {
        width: 0,
        height: 0,
        startX: k,
        startY: L,
        x: k,
        y: L
      }, s.value = !0, a.selectionStart(P);
    }
    function A(P) {
      var U, x;
      if (!e.isSelecting || !R.value || !c.value)
        return;
      if (!D.value)
        return a.paneMouseMove(P);
      s.value || (s.value = !0), d.value && (d.value = !1);
      const k = Jo(P, R.value), L = (U = c.value.startX) != null ? U : 0, K = (x = c.value.startY) != null ? x : 0, oe = {
        ...c.value,
        x: k.x < L ? k.x : L,
        y: k.y < K ? k.y : K,
        width: Math.abs(k.x - L),
        height: Math.abs(k.y - K)
      }, $ = pi(
        o.value,
        c.value,
        r.value,
        v.value === Wn.Partial
      ), Y = rn($, i.value);
      p.value = $.length, O.value = Y.length, c.value = oe, w([...$, ...Y]);
    }
    function C(P) {
      !D.value || (!s.value && c.value && P.target === M.value && G(P), d.value = p.value > 0, I(), a.selectionEnd(P));
    }
    function B(P) {
      var k;
      if (!D.value)
        return a.paneMouseLeave(P);
      s.value && (d.value = p.value > 0, (k = a.selectionEnd) == null || k.call(a, P)), I();
    }
    function F(P) {
      D.value || a.paneMouseEnter(P);
    }
    return (P, k) => (te(), re("div", {
      ref_key: "container",
      ref: M,
      key: `pane-${z(t)}`,
      class: Oe(["vue-flow__pane vue-flow__container", [{ selection: e.isSelecting }]]),
      onClick: G,
      onContextmenu: Z,
      onWheel: j,
      onMouseenter: F,
      onMousedown: m,
      onMousemove: A,
      onMouseup: C,
      onMouseleave: B
    }, [
      ve(P.$slots, "default"),
      z(s) && z(c) ? (te(), Ne(Vl, { key: 0 })) : Ee("", !0),
      z(d) ? (te(), Ne(Ll, { key: 1 })) : Ee("", !0)
    ], 34));
  }
}), Vc = { class: "vue-flow__nodes vue-flow__container" }, Fc = {
  name: "Nodes"
}, Yc = /* @__PURE__ */ ce({
  ...Fc,
  setup(e) {
    const t = Re(an), n = ue(), o = N(n, "nodesDraggable"), i = N(n, "nodesFocusable"), r = N(n, "elementsSelectable"), a = N(n, "nodesConnectable"), s = N(n, "getNodes"), l = N(n, "getNodeTypes"), u = N(n, "updateNodeDimensions"), c = N(n, "emits"), f = (v) => typeof v > "u" ? o.value : v, d = (v) => typeof v > "u" ? r.value : v, w = (v) => typeof v > "u" ? a.value : v, g = (v) => typeof v > "u" ? i.value : v, h = ie();
    be(() => {
      const v = [];
      let b = !1;
      const S = (y) => {
        v.push(y), v.length === s.value.length && je(() => {
          b = !0, c.value.nodesInitialized();
        });
      };
      h.value = new ResizeObserver((y) => {
        const M = y.map((p) => {
          const O = p.target.getAttribute("data-id");
          return b || S(O), {
            id: O,
            nodeElement: p.target
          };
        });
        u.value(M);
      });
    }), Hn(() => {
      var v;
      return (v = h.value) == null ? void 0 : v.disconnect();
    });
    const _ = (v, b) => {
      const S = v || "default";
      let y = b != null ? b : l.value[S];
      const M = tn();
      if (typeof y == "string" && M) {
        const O = Object.keys(M.appContext.components);
        O && O.includes(S) && (y = ii(S, !1));
      }
      if (typeof y != "string")
        return y;
      const p = t == null ? void 0 : t[`node-${S}`];
      return p != null && p({}) ? p : (he(`Node type "${v}" not found and no node-slot detected. Using fallback type "default".`), !1);
    };
    return (v, b) => (te(), re("div", Vc, [
      h.value ? (te(!0), re(Me, { key: 0 }, rt(s.value, (S) => (te(), Ne(z(ul), {
        id: S.id,
        key: S.id,
        "resize-observer": h.value,
        type: _(S.type, S.template),
        name: S.type || "default",
        draggable: f(S.draggable),
        selectable: d(S.selectable),
        connectable: w(S.connectable),
        focusable: g(S.focusable),
        node: S
      }, null, 8, ["id", "resize-observer", "type", "name", "draggable", "selectable", "connectable", "focusable", "node"]))), 128)) : Ee("", !0)
    ]));
  }
}), Xc = ["id", "markerWidth", "markerHeight", "markerUnits", "orient"], Zc = ["stroke", "stroke-width", "fill"], Kc = ["stroke", "stroke-width"], Wc = {
  name: "MarkerType"
}, Gc = /* @__PURE__ */ ce({
  ...Wc,
  props: {
    id: null,
    type: null,
    color: { default: "none" },
    width: { default: 12.5 },
    height: { default: 12.5 },
    markerUnits: { default: "strokeWidth" },
    orient: { default: "auto-start-reverse" },
    strokeWidth: { default: 1 }
  },
  setup(e) {
    return (t, n) => (te(), re("marker", {
      id: e.id,
      class: "vue-flow__arrowhead",
      viewBox: "-10 -10 20 20",
      refX: "0",
      refY: "0",
      markerWidth: `${e.width}`,
      markerHeight: `${e.height}`,
      markerUnits: e.markerUnits,
      orient: e.orient
    }, [
      e.type === "arrowclosed" ? (te(), re("polyline", {
        key: 0,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: e.color,
        points: "-5,-4 0,0 -5,4 -5,-4"
      }, null, 8, Zc)) : Ee("", !0),
      e.type === "arrow" ? (te(), re("polyline", {
        key: 1,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: "none",
        points: "-5,-4 0,0 -5,4"
      }, null, 8, Kc)) : Ee("", !0)
    ], 8, Xc));
  }
}), Uc = {
  name: "MarkerDefinitions"
}, qc = /* @__PURE__ */ ce({
  ...Uc,
  setup(e) {
    const t = ue(), n = N(t, "id"), o = N(t, "edges"), i = N(t, "connectionLineOptions"), r = N(t, "defaultMarkerColor"), a = ne(() => {
      const s = [], l = [], u = (c) => {
        if (c) {
          const f = Ve(c, n.value);
          s.includes(f) || (typeof c == "object" ? l.push({ ...c, id: f, color: c.color || r.value }) : l.push({ id: f, color: r.value, type: c }), s.push(f));
        }
      };
      return [i.value.markerEnd, i.value.markerStart].forEach(u), o.value.reduce((c, f) => ([f.markerStart, f.markerEnd].forEach(u), c.sort((d, w) => d.id.localeCompare(w.id))), l), l;
    });
    return (s, l) => (te(), re("defs", null, [
      (te(!0), re(Me, null, rt(z(a), (u) => (te(), Ne(Gc, {
        id: u.id,
        key: u.id,
        type: u.type,
        color: u.color,
        width: u.width,
        height: u.height,
        markerUnits: u.markerUnits,
        "stroke-width": u.strokeWidth,
        orient: u.orient
      }, null, 8, ["id", "type", "color", "width", "height", "markerUnits", "stroke-width", "orient"]))), 128))
    ]));
  }
}), Qc = {
  key: 0,
  class: "vue-flow__edges vue-flow__connectionline vue-flow__container"
}, jc = {
  name: "Edges"
}, Jc = /* @__PURE__ */ ce({
  ...jc,
  setup(e) {
    const t = Re(an), n = ue();
    N(n, "emits"), N(n, "connectionMode"), N(n, "edgeUpdaterRadius");
    const o = N(n, "onPaneReady"), i = N(n, "connectionStartHandle"), r = N(n, "nodesConnectable"), a = N(n, "edgesUpdatable");
    N(n, "edgesFocusable");
    const s = N(n, "elementsSelectable"), l = N(n, "getSelectedNodes"), u = N(n, "getSelectedEdges");
    N(n, "nodesSelectionActive");
    const c = N(n, "getNode");
    N(n, "getNodes");
    const f = N(n, "getEdges"), d = N(n, "getEdgeTypes");
    N(n, "addSelectedEdges");
    const w = N(n, "noPanClassName"), g = N(n, "elevateEdgesOnSelect"), h = (O) => typeof O > "u" ? s.value : O, _ = (O) => typeof O > "u" ? a.value : O, v = fo(
      () => {
        var O;
        return (O = i.value) == null ? void 0 : O.nodeId;
      },
      () => {
        var O;
        return (O = i.value) != null && O.nodeId ? c.value(i.value.nodeId) : !1;
      }
    ), b = fo(
      () => {
        var O;
        return (O = i.value) == null ? void 0 : O.nodeId;
      },
      () => {
        var O, R;
        return !!(v.value && (typeof v.value.connectable > "u" ? r.value : v.value.connectable) && ((O = i.value) == null ? void 0 : O.nodeId) && ((R = i.value) == null ? void 0 : R.type));
      }
    );
    let S = ie([]), y = Vt();
    o.value(() => {
      y || (y = Vt()), y.run(() => {
        le(
          [l, f, () => g.value ? u.value : []],
          () => {
            g.value ? je(() => S.value = Ml(f.value, c.value)) : S.value = [
              {
                isMaxLevel: !0,
                edges: f.value,
                level: 0
              }
            ];
          },
          { immediate: !0 }
        );
      });
    }), Hn(() => {
      y == null || y.stop(), y = null;
    });
    const M = (O, R) => {
      const D = O || "default";
      let I = R != null ? R : d.value[D];
      const G = tn();
      if (typeof I == "string" && G) {
        const j = Object.keys(G.appContext.components);
        j && j.includes(D) && (I = ii(D, !1));
      }
      if (I && typeof I != "string")
        return I;
      const Z = t == null ? void 0 : t[`edge-${D}`];
      return Z != null && Z({}) ? Z : (he(`Edge type "${O}" not found and no edge-slot detected. Using fallback type "default".`), !1);
    }, p = (O) => {
      const R = O.class instanceof Function ? O.class(O) : O.class;
      return [w.value, R];
    };
    return (O, R) => (te(), re(Me, null, [
      (te(!0), re(Me, null, rt(S.value, (D) => (te(), re("svg", {
        key: D.level,
        class: "vue-flow__edges vue-flow__container",
        style: ze(`z-index: ${D.level}`)
      }, [
        D.isMaxLevel ? (te(), Ne(qc, { key: 0 })) : Ee("", !0),
        it("g", null, [
          (te(!0), re(Me, null, rt(D.edges, (I) => (te(), Ne(z(zl), {
            id: I.id,
            key: I.id,
            edge: I,
            type: M(I.type, I.template),
            name: I.type || "default",
            "source-node": c.value(I.source),
            "target-node": c.value(I.target),
            selectable: h(I.selectable),
            updatable: _(I.updatable),
            class: Oe(p(I))
          }, null, 8, ["id", "edge", "type", "name", "source-node", "target-node", "selectable", "updatable", "class"]))), 128))
        ])
      ], 4))), 128)),
      b.value && !!v.value ? (te(), re("svg", Qc, [
        Ze(Dl, { "source-node": v.value }, null, 8, ["source-node"])
      ])) : Ee("", !0)
    ], 64));
  }
}), ed = /* @__PURE__ */ it("div", { class: "vue-flow__edge-labels" }, null, -1), td = {
  name: "Transform"
}, nd = /* @__PURE__ */ ce({
  ...td,
  setup(e) {
    const { id: t, viewport: n, dimensions: o, fitViewOnInit: i, emits: r, fitView: a, ...s } = ue(), l = async (c) => {
      const f = bt();
      return "screen" in f && await Ke(c).toMatch(({ height: d, width: w }) => !isNaN(w) && w > 0 && !isNaN(d) && d > 0), !0;
    };
    let u = ie(!1);
    return be(async () => {
      await l(o.value), u.value = !0, r.paneReady({
        id: t,
        viewport: n,
        dimensions: o,
        fitViewOnInit: i,
        fitView: a,
        emits: r,
        ...s
      }), i != null && i.value && a();
    }), (c, f) => (te(), re("div", {
      key: `transform-${z(t)}`,
      class: "vue-flow__transformationpane vue-flow__container",
      style: ze({ transform: `translate(${z(n).x}px,${z(n).y}px) scale(${z(n).zoom})`, opacity: u.value ? void 0 : 0 })
    }, [
      Ze(Jc),
      ed,
      Ze(Yc),
      ve(c.$slots, "default")
    ], 4));
  }
}), od = {
  name: "Viewport"
}, id = /* @__PURE__ */ ce({
  ...od,
  setup(e) {
    const t = ue(), n = N(t, "id"), o = N(t, "minZoom"), i = N(t, "maxZoom"), r = N(t, "defaultViewport"), a = N(t, "translateExtent"), s = N(t, "dimensions"), l = N(t, "zoomActivationKeyCode"), u = N(t, "selectionKeyCode"), c = N(t, "panActivationKeyCode"), f = N(t, "panOnScroll"), d = N(t, "panOnScrollMode"), w = N(t, "panOnScrollSpeed"), g = N(t, "panOnDrag"), h = N(t, "zoomOnDoubleClick"), _ = N(t, "zoomOnPinch"), v = N(t, "zoomOnScroll"), b = N(t, "preventScrolling"), S = N(t, "noWheelClassName"), y = N(t, "noPanClassName"), M = N(t, "setState"), p = N(t, "emits"), O = N(t, "connectionStartHandle"), R = N(t, "userSelectionActive"), D = N(t, "paneDragging"), I = ie();
    let G = ie(!1), Z = ie(!1), j = ie(!1);
    const m = ($, Y) => Y === 2 && Array.isArray($) && $.includes(2), A = vt(c.value), C = ne(() => !!O.value), B = ne(() => !G.value && g.value && A.value), F = ne(
      () => u.value !== !0 && G.value || u.value === !0 && B.value !== !0
    ), P = ($, Y) => $.x !== Y.x && !isNaN(Y.x) || $.y !== Y.y && !isNaN(Y.y) || $.zoom !== Y.k && !isNaN(Y.k), k = ($) => ({
      x: $.x,
      y: $.y,
      zoom: $.k
    }), L = () => {
      if (!I.value)
        return;
      const { width: $, height: Y } = nn(I.value);
      s.value.width = $, s.value.height = Y;
    }, K = ($, Y) => $.target.closest(`.${Y}`);
    let oe = ie({
      x: 0,
      y: 0,
      zoom: 0
    });
    return be(() => {
      Zr(I, L);
      const $ = bt();
      Fn($, "resize", L);
    }), be(() => {
      const $ = I.value, Y = $.getBoundingClientRect(), U = Tc().scaleExtent([o.value, i.value]).translateExtent(a.value), x = me($).call(U), E = x.on("wheel.zoom"), H = fn.translate(r.value.x, r.value.y).scale(Yt(r.value.zoom, o.value, i.value)), V = [
        [0, 0],
        [Y.width, Y.height]
      ], Q = U.constrain()(H, V, a.value);
      U.transform(x, Q), M.value({
        d3Zoom: U,
        d3Selection: x,
        d3ZoomHandler: E,
        viewport: { x: H.x, y: H.y, zoom: H.k },
        viewportRef: $
      });
      const W = (T) => {
        G.value = T, T && R.value && !Z.value ? U.on("zoom", null) : !T && !R.value && U.on("zoom", (J) => {
          var de;
          M.value({ viewport: { x: J.transform.x, y: J.transform.y, zoom: J.transform.k } });
          const se = k(J.transform);
          j.value = m(g.value, (de = J.sourceEvent) == null ? void 0 : de.button), p.value.viewportChange(se), p.value.move({ event: J, flowTransform: se });
        });
      };
      vt(u.value, W), W(!1);
      const ee = vt(l.value);
      U.on("start", (T) => {
        var se;
        if (!T.sourceEvent)
          return null;
        Z.value = !0;
        const J = k(T.transform);
        ((se = T.sourceEvent) == null ? void 0 : se.type) === "mousedown" && M.value({ paneDragging: !0 }), oe.value = J, p.value.viewportChangeStart(J), p.value.moveStart({ event: T, flowTransform: J });
      }), U.on("end", (T) => {
        var J;
        if (!T.sourceEvent)
          return null;
        if (Z.value = !1, M.value({ paneDragging: !1 }), m(g.value, (J = T.sourceEvent) == null ? void 0 : J.button) && !j.value && p.value.paneContextMenu(T.sourceEvent), j.value = !1, P(oe.value, T.transform)) {
          const se = k(T.transform);
          oe.value = se, p.value.viewportChangeEnd(se), p.value.moveEnd({ event: T, flowTransform: se });
        }
      }), ni(() => {
        f.value && !ee.value && !R.value ? x.on("wheel", (T) => {
          if (K(T, S.value))
            return !1;
          T.preventDefault(), T.stopImmediatePropagation();
          const J = x.property("__zoom").k || 1;
          if (T.ctrlKey && _.value) {
            const Ct = we(T), lr = -T.deltaY * (T.deltaMode === 1 ? 0.05 : T.deltaMode ? 1 : 2e-3) * 10, ur = J * 2 ** lr;
            U.scaleTo(x, ur, Ct);
            return;
          }
          const se = T.deltaMode === 1 ? 20 : 1, de = d.value === Zt.Vertical ? 0 : T.deltaX * se, St = d.value === Zt.Horizontal ? 0 : T.deltaY * se;
          U.translateBy(x, -(de / J) * w.value, -(St / J) * w.value);
        }).on("wheel.zoom", null) : typeof E < "u" && x.on("wheel", (T) => {
          if (!b.value || K(T, S.value))
            return null;
          T.preventDefault();
        }).on("wheel.zoom", E);
      }), U.filter((T) => {
        var St, Ct;
        const J = ee.value || v.value, se = _.value && T.ctrlKey;
        if (T.button === 1 && T.type === "mousedown" && (((St = T.target) == null ? void 0 : St.closest(".vue-flow__node")) || ((Ct = T.target) == null ? void 0 : Ct.closest(".vue-flow__edge"))))
          return !0;
        if (!g.value && !J && !f.value && !h.value && !_.value || R.value || !h.value && T.type === "dblclick" || K(T, S.value) && T.type === "wheel" || K(T, y.value) && T.type !== "wheel" || !_.value && T.ctrlKey && T.type === "wheel" || !J && !f.value && !se && T.type === "wheel" || !g.value && (T.type === "mousedown" || T.type === "touchstart") || Array.isArray(g.value) && !g.value.includes(T.button) && (T.type === "mousedown" || T.type === "touchstart"))
          return !1;
        const de = Array.isArray(g.value) && g.value.includes(T.button) || !T.button || T.button <= 1;
        return (!T.ctrlKey || T.type === "wheel") && de;
      });
    }), ($, Y) => (te(), re("div", {
      ref_key: "viewportEl",
      ref: I,
      key: `viewport-${n.value}`,
      class: "vue-flow__viewport vue-flow__container"
    }, [
      Ze(Lc, {
        "is-selecting": z(F),
        class: Oe({ connecting: C.value, dragging: D.value, draggable: !!g.value })
      }, {
        default: He(() => [
          Ze(nd, null, {
            default: He(() => [
              ve($.$slots, "zoom-pane")
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["is-selecting", "class"]),
      ve($.$slots, "default")
    ]));
  }
}), rd = ["id"], ad = ["id"], sd = ["id"], ld = /* @__PURE__ */ ce({
  __name: "A11yDescriptions",
  setup(e) {
    const { id: t, disableKeyboardA11y: n, ariaLiveMessage: o } = ue(), i = {
      position: "absolute",
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0px, 0px, 0px, 0px)",
      clipPath: "inset(100%)"
    };
    return (r, a) => (te(), re(Me, null, [
      it("div", {
        id: `${z(Hi)}-${z(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select a node. " + Nn(z(n) ? "" : "You can then use the arrow keys to move the node around.") + " You can then use the arrow keys to move the node around, press delete to remove it and press escape to cancel. ", 9, rd),
      it("div", {
        id: `${z(Li)}-${z(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select an edge. You can then press delete to remove it or press escape to cancel. ", 8, ad),
      z(n) ? Ee("", !0) : (te(), re("div", {
        key: 0,
        id: `${z(al)}-${z(t)}`,
        "aria-live": "assertive",
        "aria-atomic": "true",
        style: i
      }, Nn(z(o)), 9, sd))
    ], 64));
  }
}), ud = {
  name: "VueFlow"
}, _d = /* @__PURE__ */ ce({
  ...ud,
  props: {
    id: null,
    modelValue: null,
    nodes: null,
    edges: null,
    edgeTypes: null,
    nodeTypes: null,
    connectionMode: null,
    connectionLineType: null,
    connectionLineStyle: { default: void 0 },
    connectionLineOptions: null,
    deleteKeyCode: null,
    selectionKeyCode: null,
    multiSelectionKeyCode: null,
    zoomActivationKeyCode: null,
    panActivationKeyCode: null,
    snapToGrid: { type: Boolean, default: void 0 },
    snapGrid: null,
    onlyRenderVisibleElements: { type: Boolean, default: void 0 },
    edgesUpdatable: { type: [Boolean, String], default: void 0 },
    nodesDraggable: { type: Boolean, default: void 0 },
    nodesConnectable: { type: Boolean, default: void 0 },
    elementsSelectable: { type: Boolean, default: void 0 },
    selectNodesOnDrag: { type: Boolean, default: void 0 },
    panOnDrag: { type: [Boolean, Array], default: void 0 },
    minZoom: null,
    maxZoom: null,
    defaultViewport: null,
    translateExtent: null,
    nodeExtent: null,
    defaultMarkerColor: null,
    zoomOnScroll: { type: Boolean, default: void 0 },
    zoomOnPinch: { type: Boolean, default: void 0 },
    panOnScroll: { type: Boolean, default: void 0 },
    panOnScrollSpeed: null,
    panOnScrollMode: null,
    zoomOnDoubleClick: { type: Boolean, default: void 0 },
    preventScrolling: { type: Boolean, default: void 0 },
    selectionMode: null,
    edgeUpdaterRadius: null,
    fitViewOnInit: { type: Boolean, default: void 0 },
    connectOnClick: { type: Boolean, default: void 0 },
    applyDefault: { type: Boolean, default: void 0 },
    autoConnect: { type: [Boolean, Function], default: void 0 },
    noDragClassName: null,
    noWheelClassName: null,
    noPanClassName: null,
    defaultEdgeOptions: null,
    elevateEdgesOnSelect: { type: Boolean, default: void 0 },
    elevateNodesOnSelect: { type: Boolean, default: void 0 },
    disableKeyboardA11y: { type: Boolean, default: void 0 },
    edgesFocusable: { type: Boolean, default: void 0 },
    nodesFocusable: { type: Boolean, default: void 0 },
    __experimentalFeatures: null
  },
  emits: ["nodesChange", "edgesChange", "nodeDoubleClick", "nodeClick", "nodeMouseEnter", "nodeMouseMove", "nodeMouseLeave", "nodeContextMenu", "nodeDragStart", "nodeDrag", "nodeDragStop", "nodesInitialized", "miniMapNodeClick", "miniMapNodeDoubleClick", "miniMapNodeMouseEnter", "miniMapNodeMouseMove", "miniMapNodeMouseLeave", "connect", "connectStart", "connectEnd", "moveStart", "move", "moveEnd", "selectionDragStart", "selectionDrag", "selectionDragStop", "selectionContextMenu", "selectionStart", "selectionEnd", "viewportChangeStart", "viewportChange", "viewportChangeEnd", "paneReady", "paneScroll", "paneClick", "paneContextMenu", "paneMouseEnter", "paneMouseMove", "paneMouseLeave", "edgeContextMenu", "edgeMouseEnter", "edgeMouseMove", "edgeMouseLeave", "edgeDoubleClick", "edgeClick", "edgeUpdateStart", "edgeUpdate", "edgeUpdateEnd", "updateNodeInternals", "update:modelValue", "update:nodes", "update:edges"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = gt(o, "modelValue", n), r = gt(o, "nodes", n), a = gt(o, "edges", n), { vueFlowRef: s, id: l, hooks: u, getNodeTypes: c, getEdgeTypes: f, $reset: d, ...w } = ue(o), g = Rc({ modelValue: i, nodes: r, edges: a }, o, {
      vueFlowRef: s,
      id: l,
      hooks: u,
      getNodeTypes: c,
      getEdgeTypes: f,
      $reset: d,
      ...w
    }), h = ie();
    return wr(() => {
      g();
    }), be(() => {
      s.value = h.value;
    }), jr(n, u), ot(an, _r()), t({
      vueFlowRef: s,
      id: l,
      hooks: u,
      getNodeTypes: c,
      getEdgeTypes: f,
      $reset: d,
      ...w
    }), (_, v) => (te(), re("div", {
      ref_key: "el",
      ref: h,
      class: "vue-flow"
    }, [
      Ze(id, null, {
        nodes: He(() => [
          (te(!0), re(Me, null, rt(Object.keys(z(c)), (b) => ve(_.$slots, `node-${b}`)), 256))
        ]),
        edges: He(() => [
          (te(!0), re(Me, null, rt(Object.keys(z(f)), (b) => ve(_.$slots, `edge-${b}`)), 256))
        ]),
        "connection-name": He(() => [
          ve(_.$slots, "connection-line")
        ]),
        "zoom-pane": He(() => [
          ve(_.$slots, "zoom-pane")
        ]),
        default: He(() => [
          ve(_.$slots, "default")
        ]),
        _: 3
      }),
      Ze(ld)
    ], 512));
  }
}), bd = /* @__PURE__ */ ce({
  __name: "Panel",
  props: {
    position: null
  },
  setup(e) {
    const t = e, { userSelectionActive: n } = ue(), o = ne(() => `${t.position}`.split("-"));
    return (i, r) => (te(), re("div", {
      class: Oe(["vue-flow__panel", z(o)]),
      style: ze({ pointerEvents: z(n) ? "none" : "all" })
    }, [
      ve(i.$slots, "default")
    ], 6));
  }
});
function Nd(e) {
  const t = e != null ? e : Re(wi, ""), n = Re(_i, null), { findEdge: o } = ue(), i = o(t);
  if (!i)
    throw new Error(`[vue-flow]: useEdge - Edge with id ${t} not found!`);
  return {
    id: t,
    edge: i,
    edgeEl: n
  };
}
export {
  un as BaseEdge,
  vl as BezierEdge,
  Fe as ConnectionLineType,
  at as ConnectionMode,
  yd as EdgeLabelRenderer,
  gl as EdgeText,
  Lt as GlobalVueFlowStorage,
  Kt as Handle,
  ra as MarkerType,
  yi as NodeIdInjection,
  Zt as PanOnScrollMode,
  bd as Panel,
  aa as PanelPosition,
  q as Position,
  Wn as SelectionMode,
  pl as SimpleBezierEdge,
  Ki as SmoothStepEdge,
  wl as StepEdge,
  bl as StraightEdge,
  _d as VueFlow,
  No as VueFlowInjection,
  gd as addEdge,
  en as applyChanges,
  xd as applyEdgeChanges,
  wd as applyNodeChanges,
  Kn as connectionExists,
  Yl as defaultEdgeTypes,
  Fl as defaultNodeTypes,
  Xi as getBezierPath,
  pd as getBoundsofRects,
  rn as getConnectedEdges,
  hd as getIncomers,
  Ve as getMarkerId,
  pi as getNodesInside,
  fd as getOutgoers,
  vi as getRectOfNodes,
  Zi as getSimpleBezierPath,
  Pn as getSmoothStepPath,
  _l as getStraightPath,
  _o as getTransformForBounds,
  md as graphPosToZoomedPos,
  Ae as isEdge,
  Xn as isNode,
  vd as updateEdge,
  Nd as useEdge,
  ma as useGetPointerPosition,
  bi as useHandle,
  sa as useNode,
  ue as useVueFlow,
  Ic as useZoomPanHelper
};
